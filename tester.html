<!doctype html>
<html lang="ja">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Keyboard & Pointer Tester — unified / visual / offline</title>
  <style>
    :root {
      --bg: #0c0f14;
      --panel: #111827;
      --panel-2: #0e1524;
      --text: #eef6ff;
      --muted: #b7c1d1;
      --accent: #7fffd4;
      --accent-2: #8fd3ff;
      --ok: #6ee7a0;
      --warn: #ffba08;
      --danger: #ff5a5a;
      --grid: #1a2540;
      --border: #213052;
      --shadow: 0 12px 30px rgba(0, 0, 0, .28);
      --key: #19233a;
      --keyEdge: #2a3b66;
      --keyGlow: rgba(127, 255, 212, .65);
      /* canvas/dials color vars (DARK default) */
      --pad-bg: var(--panel-2);
      --grid-x: rgba(173, 216, 255, .50);
      --grid-y: rgba(127, 255, 212, .38);
      --trail: rgba(143, 211, 255, .80);
      --cross-fill: rgba(127, 255, 212, .90);
      --cross-stroke: rgba(127, 255, 212, .60);
      --ptr-line: rgba(143, 211, 255, .95);
      --ptr-tip: rgba(127, 255, 212, .95);
      --ptr-arc: rgba(143, 211, 255, .35);
      --scr-line: rgba(95, 211, 154, .95);
      --scr-tip: rgba(110, 231, 160, .95);
      --scr-arc: rgba(110, 231, 160, .35);
    }

    [data-theme="light"] {
      --bg: #f7fbff;
      --panel: #ffffff;
      --panel-2: #f3f8ff;
      --text: #0b1220;
      --muted: #475569;
      --accent: #0ea5e9;
      --accent-2: #3757ff;
      --ok: #059669;
      --warn: #b45309;
      --danger: #dc2626;
      --grid: #e5ecff;
      --border: #cfe0ff;
      --shadow: 0 6px 18px rgba(0, 0, 0, .08);
      --key: #eef3ff;
      --keyEdge: #cbd8ff;
      --keyGlow: rgba(55, 87, 255, .35);
      --pad-bg: var(--panel-2);
      --grid-x: rgba(2, 6, 23, .18);
      --grid-y: rgba(2, 6, 23, .12);
      --trail: rgba(37, 99, 235, .75);
      --cross-fill: #0ea5e9;
      --cross-stroke: #075985;
      --ptr-line: #2563eb;
      --ptr-tip: #0ea5e9;
      --ptr-arc: rgba(37, 99, 235, .40);
      --scr-line: #16a34a;
      --scr-tip: #22c55e;
      --scr-arc: rgba(34, 197, 94, .40);
    }

    [data-theme="light"] .kbdWrap {
      box-shadow: none;
    }

    [data-theme="pop"] {
      --bg: #fffdf5;
      --panel: #ffffff;
      --panel-2: #fff7e6;
      --text: #2f2a1d;
      --muted: #6b6250;
      --accent: #f59e0b;
      --accent-2: #10b981;
      --ok: #22c55e;
      --warn: #fbbf24;
      --danger: #ef4444;
      --grid: #ffecc7;
      --border: #ffe1a3;
      --shadow: 0 10px 26px rgba(245, 158, 11, .20);
      --key: #fffaf0;
      --keyEdge: #ffe2b3;
      --keyGlow: rgba(251, 191, 36, .45);
      --pad-bg: var(--panel-2);
      --grid-x: rgba(251, 191, 36, .60);
      --grid-y: rgba(52, 211, 153, .60);
      --trail: rgba(52, 211, 153, .85);
      --cross-fill: #10b981;
      --cross-stroke: #f59e0b;
      --ptr-line: #10b981;
      --ptr-tip: #34d399;
      --ptr-arc: rgba(16, 185, 129, .45);
      --scr-line: #f59e0b;
      --scr-tip: #fbbf24;
      --scr-arc: rgba(251, 191, 36, .45);
    }

    [data-theme="pop"] .kbdWrap {
      box-shadow: none;
    }

    [data-theme="classic"] {
      --bg: #0e0e10;
      --panel: #17181b;
      --panel-2: #111215;
      --text: #f2f2f2;
      --muted: #c7c7c7;
      --accent: #e5e7eb;
      --accent-2: #a3a3a3;
      --ok: #a3e635;
      --warn: #f59e0b;
      --danger: #ef4444;
      --grid: #202225;
      --border: #3a3c40;
      --shadow: 0 10px 24px rgba(0, 0, 0, .25);
      --key: #1b1c1f;
      --keyEdge: #2b2c30;
      --keyGlow: rgba(229, 231, 235, .35);
      --pad-bg: var(--panel-2);
      --grid-x: rgba(255, 255, 255, .50);
      --grid-y: rgba(255, 255, 255, .35);
      --trail: rgba(229, 231, 235, .85);
      --cross-fill: #e5e7eb;
      --cross-stroke: #9ca3af;
      --ptr-line: #e5e7eb;
      --ptr-tip: #f3f4f6;
      --ptr-arc: rgba(229, 231, 235, .40);
      --scr-line: #a3e635;
      --scr-tip: #bef264;
      --scr-arc: rgba(163, 230, 53, .40);
    }

    html,
    body {
      height: 100%
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Noto Sans JP, sans-serif
    }

    body:fullscreen {
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: auto;
    }

    .wrap {
      width: min(1728px, 90vw);
      margin: 0 auto;
      padding: 16px 16px 28px
    }

    header {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      margin: 6px 0 12px
    }

    .title {
      font-weight: 800;
      letter-spacing: .2px;
      display: flex;
      align-items: center;
      gap: 10px
    }

    .title small {
      opacity: .75;
      font-weight: 600
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center
    }

    .card {
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden
    }

    .card .body {
      padding: 12px 16px
    }

    button,
    .chip {
      appearance: none;
      border: 1px solid var(--border);
      background: var(--panel-2);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 2px 0 rgba(0, 0, 0, .08);
      transition: transform .05s ease, background .2s ease, border .2s ease
    }

    button:hover {
      background: #1b2338
    }

    button:active {
      transform: translateY(1px)
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px
    }

    .muted {
      color: var(--muted)
    }

    .spacer {
      flex: 1
    }

    .hint {
      font-size: 13px;
      opacity: .9;
      margin: .25rem 0
    }

    .lead {
      font-weight: 700
    }

    /* unified layout */
    #unified {
      display: grid;
      grid-template-columns: 4fr 3fr;
      gap: 16px
    }

    @media (max-width:980px) {
      #unified {
        grid-template-columns: 1fr
      }
    }

    /* left column */
    .leftCol {
      display: grid;
      grid-template-rows: auto auto;
      gap: 12px
    }

    textarea#typingArea {
      width: 96%;
      min-height: 240px;
      resize: vertical;
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 14px;
      background: var(--panel-2);
      color: var(--text);
      font-size: 18px;
      line-height: 1.7
    }

    /* On-screen keyboard */
    .kbdWrap {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 48px 16px;
      background: linear-gradient(160deg, var(--panel), var(--panel-2));
      box-shadow: inset 0 2px 8px rgba(0, 0, 0, .3), 0 4px 12px rgba(0, 0, 0, .3);
    }

    .keyboard {
      display: grid;
      grid-template-columns: repeat(74, minmax(0, 1fr));
      grid-auto-rows: clamp(30px, 2.8vw, 40px);
      gap: 2px;
      align-items: stretch
    }

    .row {
      display: contents
    }

    .k {
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      border-radius: 6px;
      background: var(--keyEdge);
      box-shadow: 0 2px 4px rgba(0, 0, 0, .4);
      font-weight: 700;
      letter-spacing: .3px;
      position: relative;
      line-height: 1.1;
      font-size: clamp(12px, 1.5vw, 15px);
      padding-inline: 4px;
      padding-bottom: 4px;
      border: 1px solid var(--border);
      transition: transform .05s ease, box-shadow .05s ease, filter .1s ease, background .05s ease;
      filter: brightness(1);
    }

    .k::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: calc(100% - 4px);
      background: var(--key);
      border-radius: 6px 6px 5px 5px;
      box-shadow: inset 0 1px 0px rgba(255, 255, 255, .15);
      border: 1px solid var(--keyEdge);
      border-bottom: 0;
      z-index: 0;
      transition: height .05s ease, background .05s ease, filter .1s ease, box-shadow .05s ease;
      filter: brightness(1);
    }

    .k>span {
      position: relative;
      z-index: 1;
    }

    .k small {
      opacity: .7;
      font-weight: 600;
      font-size: .78em;
      display: block;
      margin-top: 2px
    }

    .k.down {
      transform: translateY(2px);
      box-shadow: 0 1px 2px rgba(0, 0, 0, .4);
      outline: none;
      color: var(--bg);
      background: var(--accent);
      filter: brightness(0.7);
    }

    .k.down::before {
      height: calc(100% - 2px);
      background: var(--accent);
      box-shadow: inset 0 1px 0px rgba(0, 0, 0, .2);
      filter: brightness(1);
    }

    .k.pressed {
      filter: brightness(0.9);
    }

    .k.pressed::before {
      filter: brightness(0.8);
    }

    [data-theme="dark"] .k.pressed,
    [data-theme="classic"] .k.pressed {
      /* ★変更: Dark/Classic 押下済み側面 */
      filter: brightness(1.2);
    }

    [data-theme="dark"] .k.pressed::before,
    [data-theme="classic"] .k.pressed::before {
      /* ★変更: Dark/Classic 押下済み上面 */
      filter: brightness(1.3);
    }

    .k[data-code="CapsLock"] {
      justify-content: center;
      text-align: center
    }

    .gap {
      pointer-events: none
    }

    .w05 {
      grid-column: span 2
    }

    .w1 {
      grid-column: span 4
    }

    .w125 {
      grid-column: span 5
    }

    .w15 {
      grid-column: span 6
    }

    .w175 {
      grid-column: span 7
    }

    .w2 {
      grid-column: span 8
    }

    .w225 {
      grid-column: span 9
    }

    .w25 {
      grid-column: span 10
    }

    .w275 {
      grid-column: span 11
    }

    .w3 {
      grid-column: span 12
    }

    .w6 {
      grid-column: span 24
    }

    .w7 {
      grid-column: span 28
    }

    .w625 {
      grid-column: span 25
    }

    .kbdRowLabel {
      position: absolute;
      bottom: 4px;
      right: 6px;
      font-size: 10px;
      letter-spacing: .1em;
      opacity: .45;
      font-weight: 600
    }

    .clusterLabel {
      font-size: .8em;
      line-height: 1.2
    }

    /* right column */
    .rightCol {
      display: grid;
      grid-template-rows: auto auto;
      gap: 12px
    }

    #padWrap {
      position: relative;
      border-radius: 14px;
      border: 1px solid var(--border);
      overflow: auto;
      height: 360px;
      cursor: crosshair;
      user-select: none;
      background: var(--pad-bg);
    }

    #padCanvas {
      display: block;
      width: 100%;
      height: 100%
    }

    #padContent {
      position: relative;
      width: 2400px;
      height: 1600px
    }

    .hud {
      position: absolute;
      left: 12px;
      top: 12px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap
    }

    .hud .chip {
      backdrop-filter: blur(8px);
      background: rgba(0, 0, 0, .25)
    }

    /* XY dials (pointer & scroll) */
    .xyMeters {
      display: flex;
      gap: 12px
    }

    .dial {
      position: relative;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px;
      background: var(--panel-2);
      flex: 0 0 auto;
    }

    .dial h3 {
      margin: 0 0 6px 0;
      font-size: 13px;
      opacity: .9
    }

    .dial canvas {
      width: 100%;
      height: 220px;
      display: block;
      border-radius: 10px;
      background: linear-gradient(180deg, rgba(255, 255, 255, .02), rgba(0, 0, 0, .05))
    }

    .dialLegend {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 6px;
      opacity: .9
    }

    .dialLegend span {
      border: 1px solid var(--border);
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, .04)
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="title">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <rect x="3" y="5" width="18" height="14" rx="3" stroke="currentColor" stroke-width="1.8" />
          <rect x="6" y="8" width="12" height="2" rx="1" fill="currentColor" />
          <rect x="6" y="12" width="4" height="2" rx="1" fill="currentColor" />
          <rect x="12" y="12" width="6" height="2" rx="1" fill="currentColor" />
        </svg>
        <span>Keyboard & Pointer Tester</span>
        <small class="muted">(Unified / Visual / Offline)</small>
      </div>
      <div class="toolbar">
        <button id="themeBtn" class="chip" title="テーマ切り替え">🖌 Theme</button>
        <button id="fsBtn" class="chip" title="フルスクリーン">⛶ Fullscreen</button>
        <button id="resetBtn" class="chip" title="全リセット">↺ Reset</button>
      </div>
    </header>

    <section class="card" id="unifiedCard">
      <div class="body" id="unified">
        <div class="leftCol">
          <div>
            <p class="hint lead">入力テストアプリです。</p>
            <div class="toolbar" style="margin:6px 0">
              <div class="spacer"></div><button id="clearText">Clear</button>
            </div>
            <textarea id="typingArea" placeholder="ここにタイプして確認（日本語IME/英語IMEどちらもOK。キーを押すと下のキーボードが光ります）"></textarea>
          </div>

          <div class="kbdWrap">
            <div class="keyboard" id="visualKb" aria-label="on-screen keyboard">
              <div class="row">
                <div class="k w1 clusterLabel" data-code="Escape"><span>Esc</span></div>
                <div class="gap w1" aria-hidden="true"></div>
                <div class="k w1 clusterLabel" data-code="F1"><span>F1</span></div>
                <div class="k w1 clusterLabel" data-code="F2"><span>F2</span></div>
                <div class="k w1 clusterLabel" data-code="F3"><span>F3</span></div>
                <div class="k w1 clusterLabel" data-code="F4"><span>F4</span></div>
                <div class="gap w05" aria-hidden="true"></div>
                <div class="k w1 clusterLabel" data-code="F5"><span>F5</span></div>
                <div class="k w1 clusterLabel" data-code="F6"><span>F6</span></div>
                <div class="k w1 clusterLabel" data-code="F7"><span>F7</span></div>
                <div class="k w1 clusterLabel" data-code="F8"><span>F8</span></div>
                <div class="gap w05" aria-hidden="true"></div>
                <div class="k w1 clusterLabel" data-code="F9"><span>F9</span></div>
                <div class="k w1 clusterLabel" data-code="F10"><span>F10</span></div>
                <div class="k w1 clusterLabel" data-code="F11"><span>F11</span></div>
                <div class="k w1 clusterLabel" data-code="F12"><span>F12</span></div>
                <div class="gap w05" aria-hidden="true"></div>
                <div class="k w1 clusterLabel" data-code="PrintScreen"><span>PrtSc</span></div>
                <div class="k w1 clusterLabel" data-code="ScrollLock"><span>ScrLk</span></div>
                <div class="k w1 clusterLabel" data-code="Pause"><span>Pause</span></div>
              </div>
              <div class="row">
                <div class="k w1 clusterLabel" data-code="Backquote"><span>~<small>`</small></span></div>
                <div class="k w1" data-code="Digit1"><span>!<small>1</small></span></div>
                <div class="k w1" data-code="Digit2"><span>@<small>2</small></span></div>
                <div class="k w1" data-code="Digit3"><span>#<small>3</small></span></div>
                <div class="k w1" data-code="Digit4"><span>$<small>4</small></span></div>
                <div class="k w1" data-code="Digit5"><span>%<small>5</small></span></div>
                <div class="k w1" data-code="Digit6"><span>^<small>6</small></span></div>
                <div class="k w1" data-code="Digit7"><span>&<small>7</small></span></div>
                <div class="k w1" data-code="Digit8"><span>*<small>8</small></span></div>
                <div class="k w1" data-code="Digit9"><span>(<small>9</small></span></div>
                <div class="k w1" data-code="Digit0"><span>)<small>0</small></span></div>
                <div class="k w1 clusterLabel" data-code="Minus"><span>_<small>-</small></span></div>
                <div class="k w1 clusterLabel" data-code="Equal"><span>+<small>=</small></span></div>
                <div class="k w2 clusterLabel" data-code="Backspace"><span>Bksp</span></div>
                <div class="gap w05" aria-hidden="true"></div>
                <div class="k w1 clusterLabel" data-code="Insert"><span>Ins</span></div>
                <div class="k w1 clusterLabel" data-code="Home"><span>Home</span></div>
                <div class="k w1 clusterLabel" data-code="PageUp"><span>PgUp</span></div>
              </div>
              <div class="row">
                <div class="k w15 clusterLabel" data-code="Tab"><span>Tab</span></div>
                <div class="k w1" data-code="KeyQ"><span>Q</span></div>
                <div class="k w1" data-code="KeyW"><span>W</span></div>
                <div class="k w1" data-code="KeyE"><span>E</span></div>
                <div class="k w1" data-code="KeyR"><span>R</span></div>
                <div class="k w1" data-code="KeyT"><span>T</span></div>
                <div class="k w1" data-code="KeyY"><span>Y</span></div>
                <div class="k w1" data-code="KeyU"><span>U</span></div>
                <div class="k w1" data-code="KeyI"><span>I</span></div>
                <div class="k w1" data-code="KeyO"><span>O</span></div>
                <div class="k w1" data-code="KeyP"><span>P</span></div>
                <div class="k w1 clusterLabel" data-code="BracketLeft"><span>{<small>[</small></span></div>
                <div class="k w1 clusterLabel" data-code="BracketRight"><span>}<small>]</small></span></div>
                <div class="k w15 clusterLabel" data-code="Backslash"><span>|<small>\</small></span></div>
                <div class="gap w05" aria-hidden="true"></div>
                <div class="k w1 clusterLabel" data-code="Delete"><span>Del</span></div>
                <div class="k w1 clusterLabel" data-code="End"><span>End</span></div>
                <div class="k w1 clusterLabel" data-code="PageDown"><span>PgDn</span></div>
              </div>
              <div class="row">
                <div class="k w175 clusterLabel" data-code="CapsLock"><span>Caps</span></div>
                <div class="k w1" data-code="KeyA"><span>A</span></div>
                <div class="k w1" data-code="KeyS"><span>S</span></div>
                <div class="k w1" data-code="KeyD"><span>D</span></div>
                <div class="k w1" data-code="KeyF"><span>F</span></div>
                <div class="k w1" data-code="KeyG"><span>G</span></div>
                <div class="k w1" data-code="KeyH"><span>H</span></div>
                <div class="k w1" data-code="KeyJ"><span>J</span></div>
                <div class="k w1" data-code="KeyK"><span>K</span></div>
                <div class="k w1" data-code="KeyL"><span>L</span></div>
                <div class="k w1 clusterLabel" data-code="Semicolon"><span>:<small>;</small></span></div>
                <div class="k w1 clusterLabel" data-code="Quote"><span>"<small>'</small></span></div>
                <div class="k w225 clusterLabel" data-code="Enter"><span>Enter</span></div>
                <div class="gap w3" aria-hidden="true"></div>
                <div class="gap w05" aria-hidden="true"></div>
              </div>
              <div class="row">
                <div class="k w225 clusterLabel" data-code="ShiftLeft"><span>Shift</span></div>
                <div class="k w1" data-code="KeyZ"><span>Z</span></div>
                <div class="k w1" data-code="KeyX"><span>X</span></div>
                <div class="k w1" data-code="KeyC"><span>C</span></div>
                <div class="k w1" data-code="KeyV"><span>V</span></div>
                <div class="k w1" data-code="KeyB"><span>B</span></div>
                <div class="k w1" data-code="KeyN"><span>N</span></div>
                <div class="k w1" data-code="KeyM"><span>M</span></div>
                <div class="k w1 clusterLabel" data-code="Comma"><span>&lt;<small>,</small></span></div>
                <div class="k w1 clusterLabel" data-code="Period"><span>&gt;<small>.</small></span></div>
                <div class="k w1 clusterLabel" data-code="Slash"><span>?<small>/</small></span></div>
                <div class="k w275 clusterLabel" data-code="ShiftRight"><span>Shift</span></div>
                <div class="gap w05" aria-hidden="true"></div>
                <div class="gap w1" aria-hidden="true"></div>
                <div class="k w1 clusterLabel" data-code="ArrowUp"><span>↑</span></div>
                <div class="gap w1" aria-hidden="true"></div>
              </div>
              <div class="row">
                <div class="k w125 clusterLabel" data-code="ControlLeft"><span>Ctrl</span></div>
                <div class="k w125 clusterLabel" data-code="MetaLeft"><span>Win</span></div>
                <div class="k w125 clusterLabel" data-code="AltLeft"><span>Alt</span></div>
                <div class="k w625 clusterLabel" data-code="Space"><span>Space</span></div>
                <div class="k w125 clusterLabel" data-code="AltRight"><span>Alt</span></div>
                <div class="k w125 clusterLabel" data-code="MetaRight"><span>Win</span></div>
                <div class="k w125 clusterLabel" data-code="ContextMenu"><span>Menu</span></div>
                <div class="k w125 clusterLabel" data-code="ControlRight"><span>Ctrl</span></div>
                <div class="gap w05" aria-hidden="true"></div>
                <div class="k w1 clusterLabel" data-code="ArrowLeft"><span>←</span></div>
                <div class="k w1 clusterLabel" data-code="ArrowDown"><span>↓</span></div>
                <div class="k w1 clusterLabel" data-code="ArrowRight"><span>→</span></div>
              </div>
            </div>
          </div>
        </div>

        <div class="rightCol">
          <p class="hint lead">カーソルを下の領域に移動すると、軌跡とスクロールの確認ができます。</p>
          <div id="padWrap">
            <div id="padContent"><canvas id="padCanvas"></canvas></div>
            <div class="hud">
              <span class="chip">Type: <b id="pType">mouse</b></span>
              <span class="chip">client: <b id="clientXY">0,0</b></span>
              <span class="chip">movement: <b id="moveXY">0,0</b></span>
              <span class="chip">Btns L/M/R: <b id="btnState">0 0 0</b></span>
            </div>
          </div>

          <div class="xyMeters">
            <div class="dial" style="width: min(350px, 38vw);">
              <h3>ポインタ速度 XY <span class="muted">(スクロールXY重ね表示)</span></h3>
              <canvas id="ptrDial"></canvas>
            </div>
            <div class="dial" style="display:none;">
              <h3>スクロール XY</h3>
              <canvas id="scrDial"></canvas>
              <div class="dialLegend">
                <span>dx=<b id="sdxOld">0</b></span>
                <span>dy=<b id="sdyOld">0</b></span>
                <span>|v|=<b id="sspdOld">0</b></span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </div>

  <script>
    (function() {
      const $ = (sel, root = document) => root.querySelector(sel);
      const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
      // ---------- Theme system ----------
      const themes = ['dark', 'light', 'pop', 'classic'];
      let themeIdx = 0;

      function applyTheme(name) {
        document.documentElement.setAttribute('data-theme', name);
      }

      function themeColors() {
        const cs = getComputedStyle(document.documentElement);
        const get = k => cs.getPropertyValue(k).trim();
        return {
          gridX: get('--grid-x'),
          gridY: get('--grid-y'),
          trail: get('--trail'),
          crossFill: get('--cross-fill'),
          crossStroke: get('--cross-stroke'),
          ptrLine: get('--ptr-line'),
          ptrTip: get('--ptr-tip'),
          ptrArc: get('--ptr-arc'),
          scrLine: get('--scr-line'),
          scrTip: get('--scr-tip'),
          scrArc: get('--scr-arc'),
          panel2: get('--panel-2')
        };
      }

      function cycleTheme() {
        themeIdx = (themeIdx + 1) % themes.length;
        applyTheme(themes[themeIdx]);
        updateThemeBtn();
        draw();
      }
      applyTheme('dark');
      const themeBtnEl = $('#themeBtn');

      function updateThemeBtn() {
        const n = document.documentElement.getAttribute('data-theme') || 'dark';
        themeBtnEl.textContent = '🎨 ' + n.charAt(0).toUpperCase() + n.slice(1);
      }
      updateThemeBtn();
      // ---------- LEFT: Keyboard highlighting ----------
      const typingArea = $('#typingArea');
      const clearBtn = $('#clearText');
      const downKeys = new Set();
      const pressedKeysHistory = new Set();

      function mapMod(code) {
        switch (code) {
          case 'ShiftRight':
            return 'ShiftLeft';
          case 'ControlRight':
            return 'ControlLeft';
          case 'AltRight':
            return 'AltLeft';
          case 'MetaRight':
            return 'MetaLeft';
          case 'OSLeft':
            return 'MetaLeft';
          case 'OSRight':
            return 'MetaRight';
          case 'AltGraph':
            return 'AltRight';
          case 'Spacebar':
            return 'Space';
          case 'IntlYen':
            return 'Backslash';
          default:
            return code;
        }
      }

      function highlight(code, isDown) {
        $$('#visualKb .k[data-code="' + CSS.escape(code) + '"]').forEach(el => {
          if (isDown) {
            el.classList.add('down');
            // .down style has higher specificity or overrides .pressed styles
          } else {
            el.classList.remove('down');
            if (pressedKeysHistory.has(code)) {
              el.classList.add('pressed');
            }
          }
        });
      }

      function onKeyDown(e) {
        const code = mapMod(e.code || e.key);
        downKeys.add(code);
        pressedKeysHistory.add(code);
        highlight(code, true);
      }

      function onKeyUp(e) {
        const code = mapMod(e.code || e.key);
        downKeys.delete(code);
        highlight(code, false);
      }
      typingArea.addEventListener('keydown', onKeyDown);
      typingArea.addEventListener('keyup', onKeyUp);
      typingArea.addEventListener('blur', () => {
        downKeys.clear();
        $$('#visualKb .k.down').forEach(k => k.classList.remove('down'));
        pressedKeysHistory.forEach(code => {
          $$('#visualKb .k[data-code="' + CSS.escape(code) + '"]').forEach(el => el.classList.add('pressed'));
        });
      }, true);
      clearBtn.addEventListener('click', () => {
        typingArea.value = '';
        typingArea.focus();
        pressedKeysHistory.clear();
        $$('#visualKb .k.pressed').forEach(k => k.classList.remove('pressed'));
      });
      $('#themeBtn').addEventListener('click', () => {
        cycleTheme();
      });
      $('#fsBtn').addEventListener('click', () => {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(() => {});
        else document.exitFullscreen().catch(() => {});
      });
      $('#resetBtn').addEventListener('click', () => {
        typingArea.value = '';
        typingArea.focus();
        downKeys.clear();
        $$('#visualKb .k.down').forEach(k => k.classList.remove('down'));
        crossX = CONTENT_W / 2;
        crossY = CONTENT_H / 2;
        trail.length = 0;
        ripples.length = 0;
        if (rippleAnim) {
          cancelAnimationFrame(rippleAnim);
          rippleAnim = null;
        }
        draw();
        pVel.x = 0;
        pVel.y = 0;
        sVel.x = 0;
        sVel.y = 0;
        lastClient = null;
        lastClientGlobal = null;
        pressedKeysHistory.clear();
        $$('#visualKb .k.pressed').forEach(k => k.classList.remove('pressed'));
      });
      // ---------- RIGHT: Pointer visual & dials ----------
      const padWrap = $('#padWrap');
      const padContent = $('#padContent');
      const pad = $('#padCanvas');
      const ctx = pad.getContext('2d');
      const CONTENT_W = 2400,
        CONTENT_H = 1600;
      const clientXY = $('#clientXY');
      const moveXY = $('#moveXY');
      const pType = $('#pType');
      const btnState = $('#btnState');
      const pVel = {
        x: 0,
        y: 0
      };
      const sVel = {
        x: 0,
        y: 0
      };
      let crossX = CONTENT_W / 2,
        crossY = CONTENT_H / 2,
        trail = [];
      const ripples = [];
      const MAX_RIPPLES = 6;
      const RIPPLE_SPEED = 2.8 / 16.7;
      const RIPPLE_DECAY_RATE = Math.log(0.95) / 16.7;
      let rippleAnim = null;
      let lastClient = null;
      let lastClientGlobal = null;
      let inPad = false;

      function size() {
        const dpr = window.devicePixelRatio || 1;
        padContent.style.width = CONTENT_W + 'px';
        padContent.style.height = CONTENT_H + 'px';
        pad.width = Math.floor(CONTENT_W * dpr);
        pad.height = Math.floor(CONTENT_H * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        draw();
      }
      window.addEventListener('resize', size, {
        passive: true
      });
      size();

      function draw() {
        const C = themeColors();
        const gridX = C.gridX,
          gridY = C.gridY,
          trailCol = C.trail,
          crossFill = C.crossFill,
          crossStroke = C.crossStroke,
          rippleCol = C.ptrLine;
        const w = pad.width / (window.devicePixelRatio || 1),
          h = pad.height / (window.devicePixelRatio || 1);
        ctx.clearRect(0, 0, w, h);
        // grid
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.lineWidth = 1;
        for (let x = 0; x < w; x += 24) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, h);
          ctx.strokeStyle = gridX;
          ctx.stroke();
        }
        for (let y = 0; y < h; y += 24) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(w, y);
          ctx.strokeStyle = gridY;
          ctx.stroke();
        }
        ctx.restore();
        // trail
        ctx.lineWidth = 2;
        ctx.save();
        for (let i = 0; i < trail.length; i++) {
          const t = trail[i];
          const a = (i + 1) / Math.max(1, trail.length);
          ctx.globalAlpha = Math.min(1, 0.2 + a * 0.8);
          ctx.strokeStyle = trailCol;
          ctx.beginPath();
          ctx.arc(t.x, t.y, 2.4, 0, Math.PI * 2);
          ctx.stroke();
        }
        ctx.restore();
        // crosshair
        ctx.fillStyle = crossFill;
        ctx.beginPath();
        ctx.arc(crossX, crossY, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = crossStroke;
        ctx.beginPath();
        ctx.arc(crossX, crossY, 18, 0, Math.PI * 2);
        ctx.stroke();
        // ripples
        ctx.save();
        ctx.strokeStyle = rippleCol;
        for (let i = 0; i < ripples.length; i++) {
          const r = ripples[i];
          if (r.alpha <= 0) continue;
          ctx.globalAlpha = r.alpha;
          ctx.beginPath();
          ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
          ctx.stroke();
        }
        ctx.restore();
      }

      function spawnRipple(x, y) {
        const now = performance.now();
        if (ripples.length >= MAX_RIPPLES) {
          ripples.splice(0, ripples.length - MAX_RIPPLES + 1);
        }
        ripples.push({
          x,
          y,
          radius: 0,
          alpha: .9,
          time: now
        });
        draw();
        if (!rippleAnim) {
          rippleAnim = requestAnimationFrame(stepRipples);
        }
      }

      function stepRipples(ts) {
        let needsRedraw = false;
        for (let i = ripples.length - 1; i >= 0; i--) {
          const r = ripples[i];
          const dt = Math.max(0, ts - (r.time || ts));
          r.time = ts;
          r.radius += dt * RIPPLE_SPEED;
          r.alpha *= Math.exp(RIPPLE_DECAY_RATE * dt);
          needsRedraw = true;
          if (r.alpha < 0.03) {
            ripples.splice(i, 1);
          }
        }
        if (needsRedraw) {
          draw();
        }
        if (ripples.length) {
          rippleAnim = requestAnimationFrame(stepRipples);
        } else {
          rippleAnim = null;
        }
      }

      function clamp(v, min, max) {
        return v < min ? min : v > max ? max : v;
      }
      padWrap.addEventListener('mouseenter', () => {
        inPad = true;
        lastClientGlobal = null;
      });
      padWrap.addEventListener('mouseleave', () => {
        inPad = false;
        lastClient = null;
      });
      // Inside the pad: update crosshair, trail, and pointer speed
      padWrap.addEventListener('mousemove', (e) => {
        const rect = padWrap.getBoundingClientRect();
        let mvX = 0,
          mvY = 0;
        if (lastClient) {
          mvX = (e.clientX - lastClient.x);
          mvY = (e.clientY - lastClient.y);
        }
        lastClient = {
          x: e.clientX,
          y: e.clientY
        };
        const cx = (e.clientX - rect.left) + padWrap.scrollLeft;
        const cy = (e.clientY - rect.top) + padWrap.scrollTop;
        crossX = clamp(cx, 0, CONTENT_W);
        crossY = clamp(cy, 0, CONTENT_H);
        clientXY.textContent = String(Math.round(crossX)) + ',' + String(Math.round(crossY));
        moveXY.textContent = String(Math.round(mvX)) + ',' + String(Math.round(mvY));
        pType.textContent = e.pointerType || 'mouse';
        trail.push({
          x: crossX,
          y: crossY
        });
        if (trail.length > 100) trail.shift();
        pVel.x += mvX;
        pVel.y += mvY;
        draw();
      });
      padWrap.addEventListener('scroll', draw, {
        passive: true
      });
      padWrap.addEventListener('mousedown', (e) => {
        const buttons = [e.buttons & 1, e.buttons & 4, e.buttons & 2].map(b => b ? 1 : 0);
        btnState.textContent = buttons.join(' ');
        spawnRipple(crossX, crossY);
      });
      padWrap.addEventListener('mouseup', (e) => {
        const buttons = [e.buttons & 1, e.buttons & 4, e.buttons & 2].map(b => b ? 1 : 0);
        btnState.textContent = buttons.join(' ');
      });
      padWrap.addEventListener('dblclick', () => {
        spawnRipple(crossX, crossY);
      });
      // Outside the pad: only update the dials (pointer & scroll)
      document.addEventListener('mousemove', (e) => {
        if (inPad) return;
        if (lastClientGlobal) {
          pVel.x += (e.clientX - lastClientGlobal.x);
          pVel.y += (e.clientY - lastClientGlobal.y);
        }
        lastClientGlobal = {
          x: e.clientX,
          y: e.clientY
        };
      }, {
        passive: true
      });
      document.addEventListener('wheel', (e) => {
        if (inPad) return;
        sVel.x += e.deltaX;
        sVel.y += -e.deltaY;
      }, {
        passive: true
      });
      // Dials
      const ptrDial = $('#ptrDial');
      const scrDial = $('#scrDial');
      const pvxEl = $('#pvx'),
        pvyEl = $('#pvy'),
        pspdEl = $('#pspd');
      const sdxEl = $('#sdx'),
        sdyEl = $('#sdy'),
        sspdEl = $('#sspd');

      function sizeDial(canvas) {
        const r = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.floor(r.width * dpr);
        canvas.height = Math.floor(r.height * dpr);
        const ctx = canvas.getContext('2d');
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        return ctx;
      }
      let ptrCtx = sizeDial(ptrDial),
        scrCtx = sizeDial(scrDial);
      window.addEventListener('resize', () => {
        ptrCtx = sizeDial(ptrDial);
        scrCtx = sizeDial(scrDial);
      }, {
        passive: true
      });

      function drawDial(ctx, vel, range, colors, theme) {
        const w = ctx.canvas.width / (window.devicePixelRatio || 1);
        const h = ctx.canvas.height / (window.devicePixelRatio || 1);
        ctx.clearRect(0, 0, w, h);
        const cx = w / 2,
          cy = h / 2,
          rad = Math.min(w, h) / 2 - 14;
        // ring grid
        ctx.save();
        ctx.strokeStyle = theme.gridX;
        for (let r = rad; r > 0; r -= rad / 4) {
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, Math.PI * 2);
          ctx.stroke();
        }
        // axis
        ctx.beginPath();
        ctx.moveTo(cx - rad, cy);
        ctx.lineTo(cx + rad, cy);
        ctx.moveTo(cx, cy - rad);
        ctx.lineTo(cx, cy + rad);
        ctx.stroke();
        ctx.restore();
        // vector
        const nx = (vel.x / range) * rad;
        const ny = (-vel.y / range) * rad; // y up
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + nx, cy + ny);
        ctx.lineWidth = 3;
        ctx.strokeStyle = colors.line;
        ctx.stroke();
        // tip
        ctx.beginPath();
        ctx.arc(cx + nx, cy + ny, 5, 0, Math.PI * 2);
        ctx.fillStyle = colors.tip;
        ctx.fill();
        // magnitude arc
        const mag = Math.hypot(vel.x, vel.y);
        const ratio = Math.min(1, mag / range);
        ctx.beginPath();
        ctx.arc(cx, cy, rad * ratio, 0, Math.PI * 2);
        ctx.lineWidth = 2;
        ctx.strokeStyle = colors.arc;
        ctx.setLineDash([6, 6]);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      function drawCombinedDial(ctx, ptrVel, scrVel, ptrRange, scrRange, ptrColors, scrColors, theme) {
        const w = ctx.canvas.width / (window.devicePixelRatio || 1);
        const h = ctx.canvas.height / (window.devicePixelRatio || 1);
        ctx.clearRect(0, 0, w, h);
        const cx = w / 2,
          cy = h / 2,
          rad = Math.min(w, h) / 2 - 14;
        // ring grid
        ctx.save();
        ctx.strokeStyle = theme.gridX;
        for (let r = rad; r > 0; r -= rad / 4) {
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, Math.PI * 2);
          ctx.stroke();
        }
        // axis
        ctx.beginPath();
        ctx.moveTo(cx - rad, cy);
        ctx.lineTo(cx + rad, cy);
        ctx.moveTo(cx, cy - rad);
        ctx.lineTo(cx, cy + rad);
        ctx.stroke();
        ctx.restore();
        
        // === スクロールXY (背面に描画) ===
        // magnitude arc (dashed) - 最初に描画
        const scrMag = Math.hypot(scrVel.x, scrVel.y);
        const scrRatio = Math.min(1, scrMag / scrRange);
        ctx.beginPath();
        ctx.arc(cx, cy, rad * scrRatio, 0, Math.PI * 2);
        ctx.lineWidth = 2;
        ctx.strokeStyle = scrColors.arc;
        ctx.setLineDash([6, 6]);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // vector
        const scrNx = (scrVel.x / scrRange) * rad;
        const scrNy = (-scrVel.y / scrRange) * rad; // y up
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + scrNx, cy + scrNy);
        ctx.lineWidth = 3;
        ctx.strokeStyle = scrColors.line;
        ctx.stroke();
        
        // hollow circle (ring) at tip
        // 外径: 8px, 内径: 6px (ポインタ速度XYの円(5px)より1px大きい内径)
        // 外周を描画
        ctx.beginPath();
        ctx.arc(cx + scrNx, cy + scrNy, 8, 0, Math.PI * 2);
        ctx.lineWidth = 2;
        ctx.strokeStyle = scrColors.tip;
        ctx.stroke();
        // 中心を背景色で塗りつぶす
        ctx.beginPath();
        ctx.arc(cx + scrNx, cy + scrNy, 6, 0, Math.PI * 2);
        ctx.fillStyle = theme.panel2;
        ctx.fill();
        
        // === ポインタ速度XY (前面に描画) ===
        // magnitude arc
        const ptrMag = Math.hypot(ptrVel.x, ptrVel.y);
        const ptrRatio = Math.min(1, ptrMag / ptrRange);
        ctx.beginPath();
        ctx.arc(cx, cy, rad * ptrRatio, 0, Math.PI * 2);
        ctx.lineWidth = 2;
        ctx.strokeStyle = ptrColors.arc;
        ctx.setLineDash([6, 6]);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // vector
        const ptrNx = (ptrVel.x / ptrRange) * rad;
        const ptrNy = (-ptrVel.y / ptrRange) * rad; // y up
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + ptrNx, cy + ptrNy);
        ctx.lineWidth = 3;
        ctx.strokeStyle = ptrColors.line;
        ctx.stroke();
        // tip (filled circle)
        ctx.beginPath();
        ctx.arc(cx + ptrNx, cy + ptrNy, 5, 0, Math.PI * 2);
        ctx.fillStyle = ptrColors.tip;
        ctx.fill();
        
        // === 凡例を右下に描画 ===
        ctx.save();
        ctx.font = '11px system-ui, sans-serif';
        const legendY = h - 10;
        const legendX = w - 10;
        
        // スクロールXY凡例（右側）
        const scrLegendX = legendX;
        ctx.strokeStyle = scrColors.tip;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(scrLegendX - 8, legendY - 6, 4, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(scrLegendX - 8, legendY - 6, 3, 0, Math.PI * 2);
        ctx.fillStyle = theme.panel2;
        ctx.fill();
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.textAlign = 'right';
        ctx.fillText('スクロール', scrLegendX - 12, legendY);
        
        // ポインタ速度XY凡例（左側、スクロールの左に配置）
        const ptrLegendX = scrLegendX - 70;
        ctx.fillStyle = ptrColors.tip;
        ctx.beginPath();
        ctx.arc(ptrLegendX - 8, legendY - 6, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.fillText('ポインタ', ptrLegendX - 12, legendY);
        
        ctx.restore();
      }

      function tick() {
        const decay = 0.90; // smooth decay
        pVel.x *= decay;
        pVel.y *= decay;
        sVel.x *= decay;
        sVel.y *= decay;
        const Cc = themeColors();
        // ポインタ速度XYにスクロールXYを重ねて描画
        drawCombinedDial(ptrCtx, pVel, sVel, 300, 600, {
          line: Cc.ptrLine,
          tip: Cc.ptrTip,
          arc: Cc.ptrArc
        }, {
          line: Cc.scrLine,
          tip: Cc.scrTip,
          arc: Cc.scrArc
        }, Cc);
        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
      // Wheel inside pad contributes to scroll dial
      padWrap.addEventListener('wheel', (e) => {
        sVel.x += e.deltaX;
        sVel.y += -e.deltaY;
      }, {
        passive: true
      });
      // ------------- Minimal Self Tests (console only) -------------
      (function selfTests() {
        const tests = [];
        const ok = (name, cond) => tests.push({
          name,
          pass: !!cond
        });
        try {
          ok('DOM要素の存在', ['typingArea', 'visualKb', 'padCanvas', 'ptrDial', 'scrDial'].every(id => document.getElementById(id)));
          // draw() should not throw
          let drew = true;
          try {
            draw();
          } catch (e) {
            drew = false;
            console.error('draw() error:', e);
          }
          ok('draw()が例外を投げない', drew);
          // theme cycle
          const before = document.documentElement.getAttribute('data-theme');
          cycleTheme();
          const after = document.documentElement.getAttribute('data-theme');
          ok('テーマ切替が機能', before !== after);
          // keyboard highlight via synthetic event
          const keyA = document.querySelector('[data-code="KeyA"]');
          let hl = true;
          try {
            typingArea.dispatchEvent(new KeyboardEvent('keydown', {
              bubbles: true,
              code: 'KeyA',
              key: 'a'
            }));
            hl = hl && keyA.classList.contains('down');
            typingArea.dispatchEvent(new KeyboardEvent('keyup', {
              bubbles: true,
              code: 'KeyA',
              key: 'a'
            }));
            hl = hl && !keyA.classList.contains('down');
            hl = hl && keyA.classList.contains('pressed'); // Check if pressed class is added
            $('#resetBtn').click(); // Reset
            hl = hl && !keyA.classList.contains('pressed'); // Check if pressed class is removed
          } catch (e) {
            hl = false;
            console.warn('synthetic key event not allowed', e);
          }
          ok('キー点灯の合成イベント (pressed含む)', hl);
          // dial updates when velocity injected
          const prev = document.getElementById('pspd').textContent;
          const prevS = document.getElementById('sspd').textContent;
          pVel.x += 120;
          pVel.y += 80;
          sVel.x += 200;
          sVel.y += -150;
          setTimeout(() => {
            ok('ポインタ速度ダイアルが更新', document.getElementById('pspd').textContent !== prev);
            ok('スクロールダイアルが更新', document.getElementById('sspd').textContent !== prevS);
            console.group('%cSelfTests', 'color:#22c55e');
            tests.forEach(t => console.log((t.pass ? '✔' : '✖'), t.name));
            console.groupEnd();
          }, 80);
        } catch (e) {
          console.warn('selfTests aborted:', e);
        }
      })();
    })();
  </script>
</body>

</html>