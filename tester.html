<!doctype html>
<html lang="ja">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Keyboard & Pointer Tester — unified / visual / offline</title>
  <style>
    :root {
      --bg: #0c0f14;
      --panel: #111827;
      --panel-2: #0e1524;
      --text: #eef6ff;
      --muted: #b7c1d1;
      --accent: #7fffd4;
      --accent-2: #8fd3ff;
      --ok: #6ee7a0;
      --warn: #ffba08;
      --danger: #ff5a5a;
      --grid: #1a2540;
      --border: #213052;
      --shadow: 0 12px 30px rgba(0, 0, 0, .28);
      --key: #19233a;
      --keyEdge: #2a3b66;
      --keyGlow: rgba(127, 255, 212, .65);
      /* canvas/dials color vars (DARK default) */
      --pad-bg: var(--panel-2);
      --grid-x: rgba(173, 216, 255, .50);
      --grid-y: rgba(127, 255, 212, .38);
      --trail: rgba(143, 211, 255, .80);
      --cross-fill: rgba(127, 255, 212, .90);
      --cross-stroke: rgba(127, 255, 212, .60);
      --ptr-line: rgba(143, 211, 255, .95);
      --ptr-tip: rgba(127, 255, 212, .95);
      --ptr-arc: rgba(143, 211, 255, .35);
      --scr-line: rgba(95, 211, 154, .95);
      --scr-tip: rgba(110, 231, 160, .95);
      --scr-arc: rgba(110, 231, 160, .35);
    }

    [data-theme="light"] {
      --bg: #f7fbff;
      --panel: #ffffff;
      --panel-2: #f3f8ff;
      --text: #0b1220;
      --muted: #475569;
      --accent: #0ea5e9;
      --accent-2: #3757ff;
      --ok: #059669;
      --warn: #b45309;
      --danger: #dc2626;
      --grid: #e5ecff;
      --border: #cfe0ff;
      --shadow: 0 6px 18px rgba(0, 0, 0, .08);
      --key: #eef3ff;
      --keyEdge: #cbd8ff;
      --keyGlow: rgba(55, 87, 255, .35);
      --pad-bg: var(--panel-2);
      --grid-x: rgba(2, 6, 23, .18);
      --grid-y: rgba(2, 6, 23, .12);
      --trail: rgba(37, 99, 235, .75);
      --cross-fill: #0ea5e9;
      --cross-stroke: #075985;
      --ptr-line: #2563eb;
      --ptr-tip: #0ea5e9;
      --ptr-arc: rgba(37, 99, 235, .40);
      --scr-line: #16a34a;
      --scr-tip: #22c55e;
      --scr-arc: rgba(34, 197, 94, .40);
    }

    [data-theme="light"] .kbdWrap {
      box-shadow: none;
    }

    [data-theme="pop"] {
      --bg: #fffdf5;
      --panel: #ffffff;
      --panel-2: #fff7e6;
      --text: #2f2a1d;
      --muted: #6b6250;
      --accent: #f59e0b;
      --accent-2: #10b981;
      --ok: #22c55e;
      --warn: #fbbf24;
      --danger: #ef4444;
      --grid: #ffecc7;
      --border: #ffe1a3;
      --shadow: 0 10px 26px rgba(245, 158, 11, .20);
      --key: #fffaf0;
      --keyEdge: #ffe2b3;
      --keyGlow: rgba(251, 191, 36, .45);
      --pad-bg: var(--panel-2);
      --grid-x: rgba(251, 191, 36, .60);
      --grid-y: rgba(52, 211, 153, .60);
      --trail: rgba(52, 211, 153, .85);
      --cross-fill: #10b981;
      --cross-stroke: #f59e0b;
      --ptr-line: #10b981;
      --ptr-tip: #34d399;
      --ptr-arc: rgba(16, 185, 129, .45);
      --scr-line: #f59e0b;
      --scr-tip: #fbbf24;
      --scr-arc: rgba(251, 191, 36, .45);
    }

    [data-theme="pop"] .kbdWrap {
      box-shadow: none;
    }

    [data-theme="classic"] {
      --bg: #0e0e10;
      --panel: #17181b;
      --panel-2: #111215;
      --text: #f2f2f2;
      --muted: #c7c7c7;
      --accent: #e5e7eb;
      --accent-2: #a3a3a3;
      --ok: #a3e635;
      --warn: #f59e0b;
      --danger: #ef4444;
      --grid: #202225;
      --border: #3a3c40;
      --shadow: 0 10px 24px rgba(0, 0, 0, .25);
      --key: #1b1c1f;
      --keyEdge: #2b2c30;
      --keyGlow: rgba(229, 231, 235, .35);
      --pad-bg: var(--panel-2);
      --grid-x: rgba(255, 255, 255, .50);
      --grid-y: rgba(255, 255, 255, .35);
      --trail: rgba(229, 231, 235, .85);
      --cross-fill: #e5e7eb;
      --cross-stroke: #9ca3af;
      --ptr-line: #e5e7eb;
      --ptr-tip: #f3f4f6;
      --ptr-arc: rgba(229, 231, 235, .40);
      --scr-line: #a3e635;
      --scr-tip: #bef264;
      --scr-arc: rgba(163, 230, 53, .40);
    }

    html,
    body {
      height: 100%
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Noto Sans JP, sans-serif
    }

    body:fullscreen {
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: auto;
    }

    .wrap {
      width: min(1728px, 90vw);
      margin: 0 auto;
      padding: 16px 16px 28px
    }

    header {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      margin: 6px 0 12px
    }

    .title {
      font-weight: 800;
      letter-spacing: .2px;
      display: flex;
      align-items: center;
      gap: 10px
    }

    .title small {
      opacity: .75;
      font-weight: 600
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center
    }

    .card {
      background: linear-gradient(180deg, var(--panel), var(--panel-2));
      border: 1px solid var(--border);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden
    }

    .card .body {
      padding: 12px 16px
    }

    .chip {
      appearance: none;
      border: 1px solid var(--border);
      background: var(--panel-2);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 2px 0 rgba(0, 0, 0, .08);
      transition: transform .05s ease, background .2s ease, border .2s ease
    }

    .chip:hover {
      background: #1b2338
    }

    .chip:active {
      transform: translateY(1px)
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px
    }

    .muted {
      color: var(--muted)
    }

    .spacer {
      flex: 1
    }

    .hint {
      font-size: 13px;
      opacity: .9;
      margin: .25rem 0
    }

    .lead {
      font-weight: 700
    }

    /* unified layout */
    #unified {
      display: grid;
      grid-template-columns: 4fr 3fr;
      gap: 16px
    }

    @media (max-width:980px) {
      #unified {
        grid-template-columns: 1fr
      }
    }

    /* left column */
    .leftCol {
      display: grid;
      grid-template-rows: auto auto;
      gap: 12px
    }

    .fieldHeader {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
      margin-bottom: 12px; /* Path Viewと同じ間隔 */
    }

    .fieldHeader > div:first-child {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .fieldHeader h3 {
      margin: 0;
      font-size: 13px;
      opacity: .9;
      color: var(--text);
      font-weight: 600;
    }

    .fieldHeader .infoText {
      margin: 0;
      font-size: 11px;
      opacity: .75;
      color: var(--muted);
      font-weight: 400;
    }

    textarea#typingArea {
      width: 100%;
      min-height: 240px;
      resize: vertical;
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 14px;
      background: var(--panel-2);
      color: var(--text);
      font-size: 18px;
      line-height: 1.7;
      box-sizing: border-box;
    }

    /* Input Matrix */
    .kbdWrap {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px 16px 16px 16px; /* 上下左右固定マージン */
      background: linear-gradient(160deg, var(--panel), var(--panel-2));
      box-shadow: inset 0 2px 8px rgba(0, 0, 0, .3), 0 4px 12px rgba(0, 0, 0, .3);
      height: 296px; /* 右カラムの要素と揃える: 280px(キーボード) + 16px(padding) = 296px */
      box-sizing: border-box;
      overflow: hidden; /* 固定高さ内に収める */
    }

    .keyboard {
      display: grid;
      grid-template-columns: repeat(74, minmax(0, 1fr));
      grid-auto-rows: clamp(30px, 2.8vw, 40px);
      gap: 2px;
      align-items: stretch
    }

    .row {
      display: contents
    }

    .k {
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      border-radius: 6px;
      background: var(--keyEdge);
      box-shadow: 0 2px 4px rgba(0, 0, 0, .4);
      font-weight: 700;
      letter-spacing: .3px;
      position: relative;
      line-height: 1.1;
      font-size: clamp(12px, 1.5vw, 15px);
      padding-inline: 4px;
      padding-bottom: 4px;
      border: 1px solid var(--border);
      transition: transform .05s ease, box-shadow .05s ease, filter .1s ease, background .05s ease;
      filter: brightness(1);
    }

    .k::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: calc(100% - 4px);
      background: var(--key);
      border-radius: 6px 6px 5px 5px;
      box-shadow: inset 0 1px 0px rgba(255, 255, 255, .15);
      border: 1px solid var(--keyEdge);
      border-bottom: 0;
      z-index: 0;
      transition: height .05s ease, background .05s ease, filter .1s ease, box-shadow .05s ease;
      filter: brightness(1);
    }

    .k>span {
      position: relative;
      z-index: 1;
    }

    .k small {
      opacity: .7;
      font-weight: 600;
      font-size: .78em;
      display: block;
      margin-top: 2px
    }

    .k.down {
      transform: translateY(2px);
      box-shadow: 0 1px 2px rgba(0, 0, 0, .4);
      outline: none;
      color: var(--bg);
      background: var(--accent);
      filter: brightness(0.7);
    }

    .k.down::before {
      height: calc(100% - 2px);
      background: var(--accent);
      box-shadow: inset 0 1px 0px rgba(0, 0, 0, .2);
      filter: brightness(1);
    }

    .k.pressed {
      filter: brightness(0.9);
    }

    .k.pressed::before {
      filter: brightness(0.8);
    }

    [data-theme="dark"] .k.pressed,
    [data-theme="classic"] .k.pressed {
      /* ★変更: Dark/Classic 押下済み側面 */
      filter: brightness(1.2);
    }

    [data-theme="dark"] .k.pressed::before,
    [data-theme="classic"] .k.pressed::before {
      /* ★変更: Dark/Classic 押下済み上面 */
      filter: brightness(1.3);
    }

    .k[data-code="CapsLock"] {
      justify-content: center;
      text-align: center
    }

    .gap {
      pointer-events: none
    }

    .w05 {
      grid-column: span 2
    }

    .w1 {
      grid-column: span 4
    }

    .w125 {
      grid-column: span 5
    }

    .w15 {
      grid-column: span 6
    }

    .w175 {
      grid-column: span 7
    }

    .w2 {
      grid-column: span 8
    }

    .w225 {
      grid-column: span 9
    }

    .w25 {
      grid-column: span 10
    }

    .w275 {
      grid-column: span 11
    }

    .w3 {
      grid-column: span 12
    }

    .w6 {
      grid-column: span 24
    }

    .w7 {
      grid-column: span 28
    }

    .w625 {
      grid-column: span 25
    }

    .kbdRowLabel {
      position: absolute;
      bottom: 4px;
      right: 6px;
      font-size: 10px;
      letter-spacing: .1em;
      opacity: .45;
      font-weight: 600
    }

    .clusterLabel {
      font-size: .8em;
      line-height: 1.2
    }

    /* right column */
    .rightCol {
      display: grid;
      grid-template-rows: auto auto;
      gap: 12px
    }

    #padWrap {
      position: relative;
      border-radius: 14px;
      border: 1px solid var(--border);
      overflow: auto;
      height: 360px;
      cursor: crosshair;
      user-select: none;
      background: var(--pad-bg);
    }

    #padCanvas {
      display: block;
      width: 100%;
      height: 100%
    }

    #padContent {
      position: relative;
      width: 2400px;
      height: 1600px
    }

    .hud {
      position: absolute;
      left: 12px;
      top: 12px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap
    }

    .hud .chip {
      backdrop-filter: blur(8px);
      background: rgba(0, 0, 0, .25)
    }

    /* Motion Compass, Scroll Compass, Velocity Graph */
    .xyMeters {
      display: flex;
      gap: 12px
    }

    .dial {
      position: relative;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 10px 6px;
      background: var(--panel-2);
      flex: 0 0 auto;
      height: 296px; /* キーボード表示部と揃える: 280px(キーボード) + 16px(padding) = 296px */
    }

    .dial h3 {
      margin: 0 0 6px 0;
      font-size: 13px;
      opacity: .9
    }

    .dial canvas {
      width: 220px;
      height: 280px;
      display: block;
      border-radius: 10px;
      background: linear-gradient(180deg, rgba(255, 255, 255, .02), rgba(0, 0, 0, .05));
      margin: 0 auto;
    }

    .barsWrap {
      position: relative;
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      background: var(--panel-2);
      height: 296px; /* キーボード表示部と揃える: 280px(キーボード) + 16px(padding) = 296px */
    }

    .barsWrap h3 {
      position: absolute;
      top: 8px;
      left: 12px;
      margin: 0;
      font-size: 13px;
      opacity: .9;
      z-index: 5;
      color: var(--text);
      font-weight: 600;
    }

    .barsWrap .infoText {
      position: absolute;
      top: 30px;
      left: 12px;
      margin: 0;
      font-size: 11px;
      opacity: .75;
      z-index: 5;
      color: var(--muted);
      font-weight: 400;
      pointer-events: none;
    }

    .barsWrap canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .totalPxDisplay {
      position: absolute;
      top: 32px;
      left: 12px;
      font-size: 48px;
      font-weight: 900;
      font-variant-numeric: tabular-nums;
      color: rgba(238, 246, 255, 0.85);
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
      pointer-events: none;
      z-index: 10;
    }

    /* 軌跡コントロールエリア */
    .trajControls {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
      margin-bottom: 0;
    }

    .trajControls .titleSection {
      display: flex;
      flex-direction: column;
      gap: 4px;
      flex: 1;
    }

    .trajControls h3 {
      margin: 0;
      font-size: 13px;
      opacity: .9;
      color: var(--text);
      font-weight: 600;
    }

    .trajControls .infoText {
      margin: 0;
      font-size: 11px;
      opacity: .75;
      color: var(--muted);
      font-weight: 400;
    }

    .trajControls .hint {
      display: none;
    }

    .controlButtons {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    /* サウンドON/OFFボタン */
    .iconBtn {
      width: 38px;
      height: 38px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--panel-2);
      display: grid;
      place-items: center;
      cursor: pointer;
      user-select: none;
      flex-shrink: 0;
      font-size: 14px;
      transition: background .2s ease;
    }

    .iconBtn:hover {
      background: rgba(255, 255, 255, .05);
    }

    .iconBtn.active {
      background: rgba(127, 255, 212, .15);
    }

    .icon {
      font-size: 18px;
      line-height: 1;
    }

    /* 100pxインジケーター */
    .pulseBox {
      width: 38px;
      height: 38px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--panel-2);
      display: grid;
      place-items: center;
      overflow: hidden;
      flex-shrink: 0;
      position: relative;
    }

    .pulseInner {
      width: 70%;
      height: 70%;
      border-radius: 6px;
      background: rgba(255, 255, 255, .08);
      transition: transform .08s ease, background .08s ease;
    }

    .pulseBox.flash .pulseInner {
      transform: scale(1.15);
      background: rgba(121, 226, 138, .6);
    }

    .pulseProg {
      position: absolute;
      inset: 0;
      pointer-events: none;
      width: 100%;
      height: 100%;
      display: block;
      z-index: 1;
    }

    .pulseInner {
      position: relative;
      z-index: 0;
    }

    .dialLegend {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 6px;
      opacity: .9
    }

    .dialLegend span {
      border: 1px solid var(--border);
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, .04)
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="title">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
          <rect x="3" y="5" width="18" height="14" rx="3" stroke="currentColor" stroke-width="1.8" />
          <rect x="6" y="8" width="12" height="2" rx="1" fill="currentColor" />
          <rect x="6" y="12" width="4" height="2" rx="1" fill="currentColor" />
          <rect x="12" y="12" width="6" height="2" rx="1" fill="currentColor" />
        </svg>
        <span>Keyboard & Pointer Tester</span>
        <small class="muted">(Unified / Visual / Offline)</small>
      </div>
      <div class="toolbar">
        <div class="iconBtn" id="themeBtn" title="テーマ切り替え"><span class="icon">🖌</span></div>
        <div class="iconBtn" id="fsBtn" title="フルスクリーン"><span class="icon">⛶</span></div>
        <div class="iconBtn" id="resetBtn" title="全リセット"><span class="icon">↺</span></div>
      </div>
    </header>

    <section class="card" id="unifiedCard">
      <div class="body" id="unified">
        <div class="leftCol">
          <div>
            <div class="fieldHeader">
              <div>
                <h3>Type Field</h3>
                <div class="infoText">入力テストアプリです。日本語IME/英語IMEどちらもOK。キーを押すと下のキーボードが光ります。</div>
              </div>
              <div class="iconBtn" id="clearText" title="クリア"><span class="icon">🗑</span></div>
            </div>
            <textarea id="typingArea" placeholder="ここにタイプして確認"></textarea>
          </div>

          <div>
            <div class="fieldHeader">
              <div>
                <h3>Input Matrix</h3>
                <div class="infoText">押下されたキーがリアルタイムで表示されます。</div>
              </div>
            </div>
          </div>
          <div class="kbdWrap">
            <div class="keyboard" id="visualKb" aria-label="Input Matrix">
              <div class="row">
                <div class="k w1 clusterLabel" data-code="Escape"><span>Esc</span></div>
                <div class="gap w1" aria-hidden="true"></div>
                <div class="k w1 clusterLabel" data-code="F1"><span>F1</span></div>
                <div class="k w1 clusterLabel" data-code="F2"><span>F2</span></div>
                <div class="k w1 clusterLabel" data-code="F3"><span>F3</span></div>
                <div class="k w1 clusterLabel" data-code="F4"><span>F4</span></div>
                <div class="gap w05" aria-hidden="true"></div>
                <div class="k w1 clusterLabel" data-code="F5"><span>F5</span></div>
                <div class="k w1 clusterLabel" data-code="F6"><span>F6</span></div>
                <div class="k w1 clusterLabel" data-code="F7"><span>F7</span></div>
                <div class="k w1 clusterLabel" data-code="F8"><span>F8</span></div>
                <div class="gap w05" aria-hidden="true"></div>
                <div class="k w1 clusterLabel" data-code="F9"><span>F9</span></div>
                <div class="k w1 clusterLabel" data-code="F10"><span>F10</span></div>
                <div class="k w1 clusterLabel" data-code="F11"><span>F11</span></div>
                <div class="k w1 clusterLabel" data-code="F12"><span>F12</span></div>
                <div class="gap w05" aria-hidden="true"></div>
                <div class="k w1 clusterLabel" data-code="PrintScreen"><span>PrtSc</span></div>
                <div class="k w1 clusterLabel" data-code="ScrollLock"><span>ScrLk</span></div>
                <div class="k w1 clusterLabel" data-code="Pause"><span>Pause</span></div>
              </div>
              <div class="row">
                <div class="k w1 clusterLabel" data-code="Backquote"><span>~<small>`</small></span></div>
                <div class="k w1" data-code="Digit1"><span>!<small>1</small></span></div>
                <div class="k w1" data-code="Digit2"><span>@<small>2</small></span></div>
                <div class="k w1" data-code="Digit3"><span>#<small>3</small></span></div>
                <div class="k w1" data-code="Digit4"><span>$<small>4</small></span></div>
                <div class="k w1" data-code="Digit5"><span>%<small>5</small></span></div>
                <div class="k w1" data-code="Digit6"><span>^<small>6</small></span></div>
                <div class="k w1" data-code="Digit7"><span>&<small>7</small></span></div>
                <div class="k w1" data-code="Digit8"><span>*<small>8</small></span></div>
                <div class="k w1" data-code="Digit9"><span>(<small>9</small></span></div>
                <div class="k w1" data-code="Digit0"><span>)<small>0</small></span></div>
                <div class="k w1 clusterLabel" data-code="Minus"><span>_<small>-</small></span></div>
                <div class="k w1 clusterLabel" data-code="Equal"><span>+<small>=</small></span></div>
                <div class="k w2 clusterLabel" data-code="Backspace"><span>Bksp</span></div>
                <div class="gap w05" aria-hidden="true"></div>
                <div class="k w1 clusterLabel" data-code="Insert"><span>Ins</span></div>
                <div class="k w1 clusterLabel" data-code="Home"><span>Home</span></div>
                <div class="k w1 clusterLabel" data-code="PageUp"><span>PgUp</span></div>
              </div>
              <div class="row">
                <div class="k w15 clusterLabel" data-code="Tab"><span>Tab</span></div>
                <div class="k w1" data-code="KeyQ"><span>Q</span></div>
                <div class="k w1" data-code="KeyW"><span>W</span></div>
                <div class="k w1" data-code="KeyE"><span>E</span></div>
                <div class="k w1" data-code="KeyR"><span>R</span></div>
                <div class="k w1" data-code="KeyT"><span>T</span></div>
                <div class="k w1" data-code="KeyY"><span>Y</span></div>
                <div class="k w1" data-code="KeyU"><span>U</span></div>
                <div class="k w1" data-code="KeyI"><span>I</span></div>
                <div class="k w1" data-code="KeyO"><span>O</span></div>
                <div class="k w1" data-code="KeyP"><span>P</span></div>
                <div class="k w1 clusterLabel" data-code="BracketLeft"><span>{<small>[</small></span></div>
                <div class="k w1 clusterLabel" data-code="BracketRight"><span>}<small>]</small></span></div>
                <div class="k w15 clusterLabel" data-code="Backslash"><span>|<small>\</small></span></div>
                <div class="gap w05" aria-hidden="true"></div>
                <div class="k w1 clusterLabel" data-code="Delete"><span>Del</span></div>
                <div class="k w1 clusterLabel" data-code="End"><span>End</span></div>
                <div class="k w1 clusterLabel" data-code="PageDown"><span>PgDn</span></div>
              </div>
              <div class="row">
                <div class="k w175 clusterLabel" data-code="CapsLock"><span>Caps</span></div>
                <div class="k w1" data-code="KeyA"><span>A</span></div>
                <div class="k w1" data-code="KeyS"><span>S</span></div>
                <div class="k w1" data-code="KeyD"><span>D</span></div>
                <div class="k w1" data-code="KeyF"><span>F</span></div>
                <div class="k w1" data-code="KeyG"><span>G</span></div>
                <div class="k w1" data-code="KeyH"><span>H</span></div>
                <div class="k w1" data-code="KeyJ"><span>J</span></div>
                <div class="k w1" data-code="KeyK"><span>K</span></div>
                <div class="k w1" data-code="KeyL"><span>L</span></div>
                <div class="k w1 clusterLabel" data-code="Semicolon"><span>:<small>;</small></span></div>
                <div class="k w1 clusterLabel" data-code="Quote"><span>"<small>'</small></span></div>
                <div class="k w225 clusterLabel" data-code="Enter"><span>Enter</span></div>
                <div class="gap w3" aria-hidden="true"></div>
                <div class="gap w05" aria-hidden="true"></div>
              </div>
              <div class="row">
                <div class="k w225 clusterLabel" data-code="ShiftLeft"><span>Shift</span></div>
                <div class="k w1" data-code="KeyZ"><span>Z</span></div>
                <div class="k w1" data-code="KeyX"><span>X</span></div>
                <div class="k w1" data-code="KeyC"><span>C</span></div>
                <div class="k w1" data-code="KeyV"><span>V</span></div>
                <div class="k w1" data-code="KeyB"><span>B</span></div>
                <div class="k w1" data-code="KeyN"><span>N</span></div>
                <div class="k w1" data-code="KeyM"><span>M</span></div>
                <div class="k w1 clusterLabel" data-code="Comma"><span>&lt;<small>,</small></span></div>
                <div class="k w1 clusterLabel" data-code="Period"><span>&gt;<small>.</small></span></div>
                <div class="k w1 clusterLabel" data-code="Slash"><span>?<small>/</small></span></div>
                <div class="k w275 clusterLabel" data-code="ShiftRight"><span>Shift</span></div>
                <div class="gap w05" aria-hidden="true"></div>
                <div class="gap w1" aria-hidden="true"></div>
                <div class="k w1 clusterLabel" data-code="ArrowUp"><span>↑</span></div>
                <div class="gap w1" aria-hidden="true"></div>
              </div>
              <div class="row">
                <div class="k w125 clusterLabel" data-code="ControlLeft"><span>Ctrl</span></div>
                <div class="k w125 clusterLabel" data-code="MetaLeft"><span>Win</span></div>
                <div class="k w125 clusterLabel" data-code="AltLeft"><span>Alt</span></div>
                <div class="k w625 clusterLabel" data-code="Space"><span>Space</span></div>
                <div class="k w125 clusterLabel" data-code="AltRight"><span>Alt</span></div>
                <div class="k w125 clusterLabel" data-code="MetaRight"><span>Win</span></div>
                <div class="k w125 clusterLabel" data-code="ContextMenu"><span>Menu</span></div>
                <div class="k w125 clusterLabel" data-code="ControlRight"><span>Ctrl</span></div>
                <div class="gap w05" aria-hidden="true"></div>
                <div class="k w1 clusterLabel" data-code="ArrowLeft"><span>←</span></div>
                <div class="k w1 clusterLabel" data-code="ArrowDown"><span>↓</span></div>
                <div class="k w1 clusterLabel" data-code="ArrowRight"><span>→</span></div>
              </div>
            </div>
          </div>
        </div>

        <div class="rightCol">
          <div class="trajControls">
            <div class="titleSection">
              <h3>Path View</h3>
              <div class="infoText">カーソルを下の領域に移動すると、軌跡とスクロールの確認ができます。</div>
            </div>
            <div class="controlButtons">
              <div class="pulseBox" id="pulseBox" title="100pxごとにフラッシュ＆チック音">
                <div class="pulseInner"></div>
                <canvas class="pulseProg" id="pulseProg"></canvas>
              </div>
              <div class="iconBtn active" id="icoSound" title="速度ピッチ音 ON/OFF"><span class="icon" id="icoSoundGlyph">🔊</span></div>
            </div>
          </div>
          <div id="padWrap">
            <div id="padContent"><canvas id="padCanvas"></canvas></div>
            <div class="hud">
              <span class="chip">Type: <b id="pType">mouse</b></span>
              <span class="chip">client: <b id="clientXY">0,0</b></span>
              <span class="chip">movement: <b id="moveXY">0,0</b></span>
              <span class="chip">Btns L/M/R: <b id="btnState">0 0 0</b></span>
            </div>
          </div>

          <div class="xyMeters">
            <div class="dial" style="width: 232px;">
              <h3>Motion Compass</h3>
              <canvas id="ptrDial"></canvas>
            </div>
            <div class="dial" style="display:none;">
              <h3>Scroll Compass</h3>
              <canvas id="scrDial"></canvas>
              <div class="dialLegend">
                <span>dx=<b id="sdxOld">0</b></span>
                <span>dy=<b id="sdyOld">0</b></span>
                <span>|v|=<b id="sspdOld">0</b></span>
              </div>
            </div>
            <div class="barsWrap" style="flex: 1; min-width: 300px;">
              <h3>Velocity Graph</h3>
              <div class="infoText" id="barsInfoText"></div>
              <canvas id="speedBars" title="距離/秒のバー（直近30秒）"></canvas>
              <div class="totalPxDisplay" id="totalPxDisplay">0 px</div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </div>

  <script>
    (function() {
      const $ = (sel, root = document) => root.querySelector(sel);
      const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
      // ---------- Theme system ----------
      const themes = ['dark', 'light', 'pop', 'classic'];
      let themeIdx = 0;

      function applyTheme(name) {
        document.documentElement.setAttribute('data-theme', name);
      }

      function themeColors() {
        const cs = getComputedStyle(document.documentElement);
        const get = k => cs.getPropertyValue(k).trim();
        return {
          grid: get('--grid'),
          gridX: get('--grid-x'),
          gridY: get('--grid-y'),
          trail: get('--trail'),
          crossFill: get('--cross-fill'),
          crossStroke: get('--cross-stroke'),
          ptrLine: get('--ptr-line'),
          ptrTip: get('--ptr-tip'),
          ptrArc: get('--ptr-arc'),
          scrLine: get('--scr-line'),
          scrTip: get('--scr-tip'),
          scrArc: get('--scr-arc'),
          panel2: get('--panel-2')
        };
      }

      function cycleTheme() {
        themeIdx = (themeIdx + 1) % themes.length;
        applyTheme(themes[themeIdx]);
        updateThemeBtn();
        draw();
      }
      applyTheme('dark');
      const themeBtnEl = $('#themeBtn');

      function updateThemeBtn() {
        const n = document.documentElement.getAttribute('data-theme') || 'dark';
        const icon = themeBtnEl.querySelector('.icon');
        if (icon) {
          icon.textContent = '🖌';
        }
      }
      updateThemeBtn();
      // ---------- LEFT: Input Matrix ----------
      const typingArea = $('#typingArea');
      const clearBtn = $('#clearText');
      const downKeys = new Set();
      const pressedKeysHistory = new Set();

      function mapMod(code) {
        switch (code) {
          case 'ShiftRight':
            return 'ShiftLeft';
          case 'ControlRight':
            return 'ControlLeft';
          case 'AltRight':
            return 'AltLeft';
          case 'MetaRight':
            return 'MetaLeft';
          case 'OSLeft':
            return 'MetaLeft';
          case 'OSRight':
            return 'MetaRight';
          case 'AltGraph':
            return 'AltRight';
          case 'Spacebar':
            return 'Space';
          case 'IntlYen':
            return 'Backslash';
          default:
            return code;
        }
      }

      function highlight(code, isDown) {
        $$('#visualKb .k[data-code="' + CSS.escape(code) + '"]').forEach(el => {
          if (isDown) {
            el.classList.add('down');
            // .down style has higher specificity or overrides .pressed styles
          } else {
            el.classList.remove('down');
            if (pressedKeysHistory.has(code)) {
              el.classList.add('pressed');
            }
          }
        });
      }

      function onKeyDown(e) {
        const code = mapMod(e.code || e.key);
        downKeys.add(code);
        pressedKeysHistory.add(code);
        highlight(code, true);
      }

      function onKeyUp(e) {
        const code = mapMod(e.code || e.key);
        downKeys.delete(code);
        highlight(code, false);
      }
      typingArea.addEventListener('keydown', onKeyDown);
      typingArea.addEventListener('keyup', onKeyUp);
      typingArea.addEventListener('blur', () => {
        downKeys.clear();
        $$('#visualKb .k.down').forEach(k => k.classList.remove('down'));
        pressedKeysHistory.forEach(code => {
          $$('#visualKb .k[data-code="' + CSS.escape(code) + '"]').forEach(el => el.classList.add('pressed'));
        });
      }, true);
      clearBtn.addEventListener('click', () => {
        typingArea.value = '';
        typingArea.focus();
        pressedKeysHistory.clear();
        $$('#visualKb .k.pressed').forEach(k => k.classList.remove('pressed'));
      });
      $('#themeBtn').addEventListener('click', () => {
        cycleTheme();
      });
      $('#fsBtn').addEventListener('click', () => {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(() => {});
        else document.exitFullscreen().catch(() => {});
      });
      $('#resetBtn').addEventListener('click', () => {
        typingArea.value = '';
        typingArea.focus();
        downKeys.clear();
        $$('#visualKb .k.down').forEach(k => k.classList.remove('down'));
        crossX = CONTENT_W / 2;
        crossY = CONTENT_H / 2;
        trail.length = 0;
        ripples.length = 0;
        if (rippleAnim) {
          cancelAnimationFrame(rippleAnim);
          rippleAnim = null;
        }
        draw();
        pVel.x = 0;
        pVel.y = 0;
        sVel.x = 0;
        sVel.y = 0;
        lastClient = null;
        lastClientGlobal = null;
        lastVs = 0;
        lastMovePos = {x: 0, y: 0, t: 0};
        totalPx = 0;
        nextPulse = 100;
        bins.length = 0;
        startedAt = 0;
        if (gain) gain.gain.value = 0;
        removePulseFlash();
        pressedKeysHistory.clear();
        $$('#visualKb .k.pressed').forEach(k => k.classList.remove('pressed'));
      });
      // ---------- RIGHT: Path View, Motion Compass, Scroll Compass, Velocity Graph ----------
      const padWrap = $('#padWrap');
      const padContent = $('#padContent');
      const pad = $('#padCanvas');
      const ctx = pad.getContext('2d');
      const CONTENT_W = 2400,
        CONTENT_H = 1600;
      const clientXY = $('#clientXY');
      const moveXY = $('#moveXY');
      const pType = $('#pType');
      const btnState = $('#btnState');
      const speedBars = $('#speedBars');
      const totalPxDisplay = $('#totalPxDisplay');
      const pulseBox = $('#pulseBox');
      const pulseInner = document.querySelector('.pulseInner');
      const pulseProg = $('#pulseProg');
      const icoSound = $('#icoSound');
      const icoSoundGlyph = $('#icoSoundGlyph');
      const pVel = {
        x: 0,
        y: 0
      };
      const sVel = {
        x: 0,
        y: 0
      };
      let crossX = CONTENT_W / 2,
        crossY = CONTENT_H / 2,
        trail = []; // {x, y, v, vs, t} - odometer方式
      const ripples = [];
      const MAX_RIPPLES = 6;
      const RIPPLE_SPEED = 2.8 / 16.7;
      const RIPPLE_DECAY_RATE = Math.log(0.95) / 16.7;
      let rippleAnim = null;
      let lastClient = null;
      let lastClientGlobal = null;
      let inPad = false;
      let lastTrailTime = 0; // 軌跡の速度計算用
      let lastVs = 0; // 平滑化速度
      let lastMovePos = {x: 0, y: 0, t: 0}; // 最後の移動位置と時刻
      
      // 速度バーグラフ用変数
      const BIN_MS = 200; // サンプリング200ms
      const SHOW_SEC = 24; // 表示約24秒
      const MAX_BINS = Math.ceil((SHOW_SEC * 1000) / BIN_MS);
      let totalPx = 0;
      let nextPulse = 100;
      let bins = []; // {tbin, dist(px), v(px/s), a(px/s^2)}
      let startedAt = 0;
      
      // オーディオ関連変数
      let ac = null, osc = null, gain = null;
      let tickOsc = null, tickGain = null;
      let sndChk = {checked: true}; // サウンド制御用

      // オーディオ初期化
      function initAudio() {
        if (ac) {
          // 既に初期化済みの場合、AudioContextがサスペンド状態なら再開
          if (ac.state === 'suspended') {
            ac.resume().catch(e => console.warn('AudioContext resume failed', e));
          }
          return;
        }
        try {
          ac = new (window.AudioContext || window.webkitAudioContext)();
          // 速度ピッチ音（連続）
          osc = ac.createOscillator();
          gain = ac.createGain();
          osc.type = 'sine';
          osc.frequency.value = 200;
          gain.gain.value = 0.0;
          osc.connect(gain).connect(ac.destination);
          osc.start();
          // 100pxチック音
          tickOsc = ac.createOscillator();
          tickGain = ac.createGain();
          tickOsc.type = 'square';
          tickOsc.frequency.value = 880;
          tickGain.gain.value = 0.0;
          tickOsc.connect(tickGain).connect(ac.destination);
          tickOsc.start();
          // AudioContextがサスペンド状態の場合は再開
          if (ac.state === 'suspended') {
            ac.resume().catch(e => console.warn('AudioContext resume failed', e));
          }
        } catch (e) {
          console.warn('Audio init failed', e);
        }
      }

      // 速度に応じたピッチ制御
      function setPitchBySpeed(v) {
        if (!ac || !sndChk.checked) return;
        // AudioContextがサスペンド状態なら再開を試みる
        if (ac.state === 'suspended') {
          ac.resume().catch(e => console.warn('AudioContext resume failed', e));
          return; // 今回はスキップ、次回から動作する
        }
        if (ac.state !== 'running') return;
        const f = Math.max(120, Math.min(2200, 120 + v * 0.25));
        osc.frequency.setTargetAtTime(f, ac.currentTime, 0.015);
        const g = Math.max(0, Math.min(0.25, v / 3000));
        gain.gain.setTargetAtTime(g, ac.currentTime, 0.02);
      }

      // 100pxチック音
      function pulseTick() {
        if (!ac || !sndChk.checked) return;
        // AudioContextがサスペンド状態なら再開を試みる
        if (ac.state === 'suspended') {
          ac.resume().catch(e => console.warn('AudioContext resume failed', e));
          return; // 今回はスキップ、次回から動作する
        }
        if (ac.state !== 'running') return;
        const t = ac.currentTime;
        tickGain.gain.cancelScheduledValues(t);
        tickGain.gain.setValueAtTime(0.0, t);
        tickGain.gain.linearRampToValueAtTime(0.18, t + 0.005);
        tickGain.gain.exponentialRampToValueAtTime(0.0008, t + 0.07);
      }

      // 100pxフラッシュ
      function doPulse() {
        pulseTick();
        pulseFlash();
      }

      function pulseFlash() {
        if (!pulseBox) return;
        pulseBox.classList.add('flash');
        setTimeout(removePulseFlash, 90);
      }

      function removePulseFlash() {
        if (!pulseBox) return;
        pulseBox.classList.remove('flash');
      }

      function size() {
        const dpr = window.devicePixelRatio || 1;
        padContent.style.width = CONTENT_W + 'px';
        padContent.style.height = CONTENT_H + 'px';
        pad.width = Math.floor(CONTENT_W * dpr);
        pad.height = Math.floor(CONTENT_H * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        
        // speedBars canvasのリサイズ
        if (speedBars) {
          const r = speedBars.getBoundingClientRect();
          speedBars.width = Math.floor(r.width * dpr);
          speedBars.height = Math.floor(r.height * dpr);
        }
        
        draw();
      }
      window.addEventListener('resize', size, {
        passive: true
      });
      size();

      function draw() {
        const C = themeColors();
        const gridX = C.gridX,
          gridY = C.gridY,
          trailCol = C.trail,
          crossFill = C.crossFill,
          crossStroke = C.crossStroke,
          rippleCol = C.ptrLine;
        const w = pad.width / (window.devicePixelRatio || 1),
          h = pad.height / (window.devicePixelRatio || 1);
        ctx.clearRect(0, 0, w, h);
        // grid
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.lineWidth = 1;
        for (let x = 0; x < w; x += 24) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, h);
          ctx.strokeStyle = gridX;
          ctx.stroke();
        }
        for (let y = 0; y < h; y += 24) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(w, y);
          ctx.strokeStyle = gridY;
          ctx.stroke();
        }
        ctx.restore();
        // trail (odometer方式: 速度ベース色相・明度 + フェードアウト)
        const nowt = performance.now();
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.save();
        for (let i = 1; i < trail.length; i++) {
          const p0 = trail[i - 1];
          const p1 = trail[i];
          const age = (nowt - p1.t) / 1000;
          const alpha = Math.max(0, 1.0 - age / 2.0); // 2秒でフェードアウト
          if (alpha <= 0) continue;
          
          // 速度に応じた色相・明度変化
          const v = p1.vs || p1.v || 0;
          const norm = Math.min(1, v / 2500);
          const hue = 200 + norm * 40;     // 200→240 (青→青紫)
          const sat = 72;
          const light = 35 + norm * 45;     // 明るさで速度感
          ctx.strokeStyle = `hsla(${hue}, ${sat}%, ${light}%, ${alpha})`;
          ctx.beginPath();
          ctx.moveTo(p0.x, p0.y);
          ctx.lineTo(p1.x, p1.y);
          ctx.stroke();
        }
        ctx.restore();
        // crosshair
        ctx.fillStyle = crossFill;
        ctx.beginPath();
        ctx.arc(crossX, crossY, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = crossStroke;
        ctx.beginPath();
        ctx.arc(crossX, crossY, 18, 0, Math.PI * 2);
        ctx.stroke();
        // ripples
        ctx.save();
        ctx.strokeStyle = rippleCol;
        for (let i = 0; i < ripples.length; i++) {
          const r = ripples[i];
          if (r.alpha <= 0) continue;
          ctx.globalAlpha = r.alpha;
          ctx.beginPath();
          ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
          ctx.stroke();
        }
        ctx.restore();
        
        // 速度バーグラフの描画
        drawBars();
        // 積算ピクセル表示の更新
        if (totalPxDisplay) {
          totalPxDisplay.textContent = `${Math.round(totalPx)} px`;
        }
        // 100pxインジケーターの進捗リング
        drawPulseProgress();
      }

      // 100pxインジケーター内の進捗リング描画
      function drawPulseProgress() {
        if (!pulseProg || !pulseBox) return;
        const c = pulseProg;
        const dpr = window.devicePixelRatio || 1;
        const ctx = c.getContext('2d');
        
        // canvasサイズを設定（毎回確認して更新）
        const boxW = pulseBox.clientWidth || 38;
        const boxH = pulseBox.clientHeight || 38;
        c.width = Math.max(1, Math.floor(boxW * dpr));
        c.height = Math.max(1, Math.floor(boxH * dpr));
        
        // Transformを設定
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        
        // 論理サイズ（CSSピクセル単位）でclear
        const W = boxW;
        const H = boxH;
        ctx.clearRect(0, 0, W, H);
        
        const cx = W / 2;
        const cy = H / 2;
        const lineWidth = 6;
        
        // 円が切れないように、lineWidth/2 + マージン2pxを確保
        const r = Math.max(5, Math.min(cx, cy) - lineWidth / 2 - 2);
        // 進捗を計算
        let prog = (totalPx % 100) / 100;
        
        // 背景の円（常に描画）
        ctx.strokeStyle = '#20324a';
        ctx.lineWidth = lineWidth;
        ctx.lineCap = 'butt'; // 端を切り揃え
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.stroke();
        
        // 中心部分を明示的に背景色で塗りつぶす（pulseInnerの緑色が透けないように）
        const innerRadius = r - lineWidth / 2 - 2;
        if (innerRadius > 0) {
          ctx.fillStyle = 'rgba(255, 255, 255, .08)'; // pulseInnerの初期背景色と同じ
          ctx.beginPath();
          ctx.arc(cx, cy, innerRadius, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // 進捗の円（進捗がある時だけ描画、ただし完全な円にはしない）
        // 進捗が非常に小さい時（10%未満）または大きい時（95%以上）は描画しない（閉じを防ぐ）
        if (prog >= 0.10 && prog <= 0.95) {
          ctx.strokeStyle = '#79e28a';
          ctx.lineWidth = lineWidth;
          ctx.lineCap = 'round'; // 端を丸くする
          ctx.beginPath();
          const startAngle = -Math.PI / 2;
          
          // 進捗を調整：最小10%、最大95%で確実に閉じないように
          let safeProg = Math.max(0.10, Math.min(prog, 0.95));
          
          // 最大角度を制限（完全な円にならないように）
          const maxAngle = 2 * Math.PI - (Math.PI / 30); // 6度のギャップ
          const angleAmount = safeProg * 2 * Math.PI;
          const endAngle = startAngle + Math.min(angleAmount, maxAngle);
          
          // 円弧を描画（開始角度はそのまま、終了角度のみ調整）
          ctx.arc(cx, cy, r, startAngle, endAngle, false);
          ctx.stroke();
        }
      }

      // 速度バーグラフ描画用のユーティリティ関数
      function drawGrid(ctx, c, gridColor) {
        ctx.save();
        ctx.strokeStyle = gridColor || '#142033'; // デフォルト色（フォールバック）
        ctx.lineWidth = 1;
        const step = 20 * (window.devicePixelRatio || 1);
        for (let x = 0; x < c.width; x += step) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, c.height);
          ctx.stroke();
        }
        for (let y = 0; y < c.height; y += step) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(c.width, y);
          ctx.stroke();
        }
        ctx.restore();
      }

      function percentile(arr, p) {
        if (!arr.length) return 0;
        const a = [...arr].sort((x, y) => x - y);
        const idx = Math.min(a.length - 1, Math.max(0, Math.floor((a.length - 1) * p)));
        return a[idx];
      }

      function drawBars() {
        if (!speedBars) return;
        const c = speedBars;
        const ctx = c.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, c.width / dpr, c.height / dpr);
        // テーマのグリッド色を使用
        const C = themeColors();
        drawGrid(ctx, c, C.grid);
        const padX = 20;  // 左右のパディング（論理ピクセル）
        const padTop = 48; // 上部パディング（タイトルと情報テキストの分）
        const padBottom = 2; // 下部パディングを最小限に
        const W = (c.width / dpr) - 2 * padX;
        const H = (c.height / dpr) - padTop - padBottom;
        const N = Math.min(MAX_BINS, bins.length);
        // 情報テキストをHTML要素に表示（canvas上ではなく）
        const infoTextEl = document.getElementById('barsInfoText');
        if (infoTextEl) {
          infoTextEl.textContent = `px/秒（${BIN_MS}msサンプル・表示約${SHOW_SEC}s） / 色=加速度`;
        }
        if (!N) return;
        const vmax = Math.max(200, ...bins.map(b => b.v));
        const absA = bins.map(b => Math.abs(b.a));
        let aRange = Math.max(1000, percentile(absA, 0.95));
        const barStep = W / MAX_BINS;
        const barW = Math.max(1, Math.floor(barStep * 0.82));

        ctx.save();
        ctx.translate(padX, (c.height / dpr) - padBottom);
        for (let i = 0; i < N; i++) {
          const b = bins[bins.length - N + i];
          const h = (b.v / vmax) * H;
          const an = Math.max(-1, Math.min(1, b.a / aRange));
          const hue = 210 + an * 90;
          const sat = 70;
          const light = 32 + Math.min(50, Math.pow(b.v / vmax, 0.8) * 50);
          ctx.fillStyle = `hsl(${hue} ${sat}% ${light}%)`;
          ctx.fillRect(i * barStep, -h, barW, h);
        }
        ctx.restore();
      }

      function spawnRipple(x, y) {
        const now = performance.now();
        if (ripples.length >= MAX_RIPPLES) {
          ripples.splice(0, ripples.length - MAX_RIPPLES + 1);
        }
        ripples.push({
          x,
          y,
          radius: 0,
          alpha: .9,
          time: now
        });
        draw();
        if (!rippleAnim) {
          rippleAnim = requestAnimationFrame(stepRipples);
        }
      }

      function stepRipples(ts) {
        let needsRedraw = false;
        for (let i = ripples.length - 1; i >= 0; i--) {
          const r = ripples[i];
          const dt = Math.max(0, ts - (r.time || ts));
          r.time = ts;
          r.radius += dt * RIPPLE_SPEED;
          r.alpha *= Math.exp(RIPPLE_DECAY_RATE * dt);
          needsRedraw = true;
          if (r.alpha < 0.03) {
            ripples.splice(i, 1);
          }
        }
        if (needsRedraw) {
          draw();
        }
        if (ripples.length) {
          rippleAnim = requestAnimationFrame(stepRipples);
        } else {
          rippleAnim = null;
        }
      }

      function clamp(v, min, max) {
        return v < min ? min : v > max ? max : v;
      }
      padWrap.addEventListener('mouseenter', () => {
        inPad = true;
        lastClientGlobal = null;
      });
      padWrap.addEventListener('mouseleave', () => {
        inPad = false;
        lastClient = null;
      });
      // Inside the pad: update crosshair, trail, and pointer speed
      padWrap.addEventListener('mousemove', (e) => {
        const rect = padWrap.getBoundingClientRect();
        let mvX = 0,
          mvY = 0;
        if (lastClient) {
          mvX = (e.clientX - lastClient.x);
          mvY = (e.clientY - lastClient.y);
        }
        lastClient = {
          x: e.clientX,
          y: e.clientY
        };
        const cx = (e.clientX - rect.left) + padWrap.scrollLeft;
        const cy = (e.clientY - rect.top) + padWrap.scrollTop;
        crossX = clamp(cx, 0, CONTENT_W);
        crossY = clamp(cy, 0, CONTENT_H);
        clientXY.textContent = String(Math.round(crossX)) + ',' + String(Math.round(crossY));
        moveXY.textContent = String(Math.round(mvX)) + ',' + String(Math.round(mvY));
        pType.textContent = e.pointerType || 'mouse';
        
        // odometer方式: 速度計算と軌跡記録
        const nowt = performance.now();
        let v = 0, vs = 0;
        if (lastMovePos.t > 0) {
          const dt = (nowt - lastMovePos.t) / 1000;
          if (dt > 0) {
            const dx = crossX - lastMovePos.x;
            const dy = crossY - lastMovePos.y;
            const d = Math.hypot(dx, dy);
            v = d / dt;
            // 平滑化速度 (EMA: α=0.3)
            vs = lastVs = 0.3 * v + 0.7 * lastVs;
            
            // 距離計測とビン更新
            if (startedAt === 0) {
              startedAt = nowt;
              initAudio();
              // AudioContextがサスペンド状態の場合、確実に再開
              if (ac && ac.state === 'suspended') {
                ac.resume().catch(e => console.warn('AudioContext resume failed', e));
              }
            }
            totalPx += d;
            
            // 速度ピッチ音
            setPitchBySpeed(v);
            
            // 100pxごとにチック音とフラッシュ
            while (totalPx >= nextPulse) {
              doPulse();
              nextPulse += 100;
            }
            
            // 200msビンへ加算
            const tbin = Math.floor((nowt - startedAt) / BIN_MS);
            if (!bins.length || bins[bins.length - 1].tbin !== tbin) {
              // 新規ビン開始、前ビンの速度と加速度を確定
              if (bins.length) {
                const prev = bins[bins.length - 1];
                prev.v = (prev.dist) / (BIN_MS / 1000);
                const preprev = bins.length > 1 ? bins[bins.length - 2] : null;
                prev.a = preprev ? (prev.v - preprev.v) / (BIN_MS / 1000) : 0;
              }
              bins.push({tbin, dist: 0, v: 0, a: 0});
              if (bins.length > MAX_BINS) bins.shift();
            }
            bins[bins.length - 1].dist += d;
          }
        }
        trail.push({
          x: crossX,
          y: crossY,
          v: v,
          vs: vs,
          t: nowt
        });
        if (trail.length > 900) trail.shift();
        lastMovePos = {x: crossX, y: crossY, t: nowt};
        
        pVel.x += mvX;
        pVel.y += mvY;
        draw();
      });
      padWrap.addEventListener('scroll', draw, {
        passive: true
      });
      padWrap.addEventListener('mousedown', (e) => {
        const buttons = [e.buttons & 1, e.buttons & 4, e.buttons & 2].map(b => b ? 1 : 0);
        btnState.textContent = buttons.join(' ');
        spawnRipple(crossX, crossY);
      });
      padWrap.addEventListener('mouseup', (e) => {
        const buttons = [e.buttons & 1, e.buttons & 4, e.buttons & 2].map(b => b ? 1 : 0);
        btnState.textContent = buttons.join(' ');
      });
      padWrap.addEventListener('dblclick', () => {
        spawnRipple(crossX, crossY);
      });
      // 音ON/OFFボタン
      if (icoSound) {
        icoSound.addEventListener('click', () => {
          sndChk.checked = !sndChk.checked;
          icoSound.classList.toggle('active', sndChk.checked);
          icoSoundGlyph.textContent = sndChk.checked ? '🔊' : '🔇';
          if (!sndChk.checked && gain) {
            gain.gain.value = 0;
            tickGain.gain.value = 0;
          }
        });
      }
      // Outside the pad: only update Motion Compass and Scroll Compass
      document.addEventListener('mousemove', (e) => {
        if (inPad) return;
        if (lastClientGlobal) {
          pVel.x += (e.clientX - lastClientGlobal.x);
          pVel.y += (e.clientY - lastClientGlobal.y);
        }
        lastClientGlobal = {
          x: e.clientX,
          y: e.clientY
        };
      }, {
        passive: true
      });
      document.addEventListener('wheel', (e) => {
        if (inPad) return;
        sVel.x += e.deltaX;
        sVel.y += -e.deltaY;
      }, {
        passive: true
      });
      // Dials
      const ptrDial = $('#ptrDial');
      const scrDial = $('#scrDial');
      const pvxEl = $('#pvx'),
        pvyEl = $('#pvy'),
        pspdEl = $('#pspd');
      const sdxEl = $('#sdx'),
        sdyEl = $('#sdy'),
        sspdEl = $('#sspd');

      function sizeDial(canvas) {
        const r = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.floor(r.width * dpr);
        canvas.height = Math.floor(r.height * dpr);
        const ctx = canvas.getContext('2d');
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        return ctx;
      }
      let ptrCtx = sizeDial(ptrDial),
        scrCtx = sizeDial(scrDial);
      window.addEventListener('resize', () => {
        ptrCtx = sizeDial(ptrDial);
        scrCtx = sizeDial(scrDial);
      }, {
        passive: true
      });

      function drawDial(ctx, vel, range, colors, theme) {
        const w = ctx.canvas.width / (window.devicePixelRatio || 1);
        const h = ctx.canvas.height / (window.devicePixelRatio || 1);
        ctx.clearRect(0, 0, w, h);
        const cx = w / 2,
          cy = h / 2,
          rad = Math.min(w, h) / 2 - 14;
        // ring grid
        ctx.save();
        ctx.strokeStyle = theme.gridX;
        for (let r = rad; r > 0; r -= rad / 4) {
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, Math.PI * 2);
          ctx.stroke();
        }
        // axis
        ctx.beginPath();
        ctx.moveTo(cx - rad, cy);
        ctx.lineTo(cx + rad, cy);
        ctx.moveTo(cx, cy - rad);
        ctx.lineTo(cx, cy + rad);
        ctx.stroke();
        ctx.restore();
        // vector
        const nx = (vel.x / range) * rad;
        const ny = (-vel.y / range) * rad; // y up
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + nx, cy + ny);
        ctx.lineWidth = 3;
        ctx.strokeStyle = colors.line;
        ctx.stroke();
        // tip
        ctx.beginPath();
        ctx.arc(cx + nx, cy + ny, 5, 0, Math.PI * 2);
        ctx.fillStyle = colors.tip;
        ctx.fill();
        // magnitude arc
        const mag = Math.hypot(vel.x, vel.y);
        const ratio = Math.min(1, mag / range);
        ctx.beginPath();
        ctx.arc(cx, cy, rad * ratio, 0, Math.PI * 2);
        ctx.lineWidth = 2;
        ctx.strokeStyle = colors.arc;
        ctx.setLineDash([6, 6]);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      function drawCombinedDial(ctx, ptrVel, scrVel, ptrRange, scrRange, ptrColors, scrColors, theme) {
        const w = ctx.canvas.width / (window.devicePixelRatio || 1);
        const h = ctx.canvas.height / (window.devicePixelRatio || 1);
        ctx.clearRect(0, 0, w, h);
        const cx = w / 2,
          cy = h / 2,
          rad = Math.min(w, h) / 2 - 14;
        // ring grid
        ctx.save();
        ctx.strokeStyle = theme.gridX;
        for (let r = rad; r > 0; r -= rad / 4) {
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, Math.PI * 2);
          ctx.stroke();
        }
        // axis
        ctx.beginPath();
        ctx.moveTo(cx - rad, cy);
        ctx.lineTo(cx + rad, cy);
        ctx.moveTo(cx, cy - rad);
        ctx.lineTo(cx, cy + rad);
        ctx.stroke();
        ctx.restore();
        
        // === Scroll Compass (背面に描画) ===
        // magnitude arc (dashed) - 最初に描画
        const scrMag = Math.hypot(scrVel.x, scrVel.y);
        const scrRatio = Math.min(1, scrMag / scrRange);
        ctx.beginPath();
        ctx.arc(cx, cy, rad * scrRatio, 0, Math.PI * 2);
        ctx.lineWidth = 2;
        ctx.strokeStyle = scrColors.arc;
        ctx.setLineDash([6, 6]);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // vector
        const scrNx = (scrVel.x / scrRange) * rad;
        const scrNy = (-scrVel.y / scrRange) * rad; // y up
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + scrNx, cy + scrNy);
        ctx.lineWidth = 3;
        ctx.strokeStyle = scrColors.line;
        ctx.stroke();
        
        // hollow circle (ring) at tip
        // 外径: 8px, 内径: 6px (Motion Compassの円(5px)より1px大きい内径)
        // 外周を描画
        ctx.beginPath();
        ctx.arc(cx + scrNx, cy + scrNy, 8, 0, Math.PI * 2);
        ctx.lineWidth = 2;
        ctx.strokeStyle = scrColors.tip;
        ctx.stroke();
        // 中心を背景色で塗りつぶす
        ctx.beginPath();
        ctx.arc(cx + scrNx, cy + scrNy, 6, 0, Math.PI * 2);
        ctx.fillStyle = theme.panel2;
        ctx.fill();
        
        // === Motion Compass (前面に描画) ===
        // magnitude arc
        const ptrMag = Math.hypot(ptrVel.x, ptrVel.y);
        const ptrRatio = Math.min(1, ptrMag / ptrRange);
        ctx.beginPath();
        ctx.arc(cx, cy, rad * ptrRatio, 0, Math.PI * 2);
        ctx.lineWidth = 2;
        ctx.strokeStyle = ptrColors.arc;
        ctx.setLineDash([6, 6]);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // vector
        const ptrNx = (ptrVel.x / ptrRange) * rad;
        const ptrNy = (-ptrVel.y / ptrRange) * rad; // y up
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + ptrNx, cy + ptrNy);
        ctx.lineWidth = 3;
        ctx.strokeStyle = ptrColors.line;
        ctx.stroke();
        // tip (filled circle)
        ctx.beginPath();
        ctx.arc(cx + ptrNx, cy + ptrNy, 5, 0, Math.PI * 2);
        ctx.fillStyle = ptrColors.tip;
        ctx.fill();
      }

      function tick() {
        const decay = 0.90; // smooth decay
        pVel.x *= decay;
        pVel.y *= decay;
        sVel.x *= decay;
        sVel.y *= decay;
        const Cc = themeColors();
        // Motion CompassにScroll Compassを重ねて描画
        drawCombinedDial(ptrCtx, pVel, sVel, 300, 600, {
          line: Cc.ptrLine,
          tip: Cc.ptrTip,
          arc: Cc.ptrArc
        }, {
          line: Cc.scrLine,
          tip: Cc.scrTip,
          arc: Cc.scrArc
        }, Cc);
        // 軌跡のフェードアウト描画（軌跡がある場合のみ）
        if (trail.length > 0) {
          draw();
        }
        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
      // Wheel inside pad contributes to Scroll Compass
      padWrap.addEventListener('wheel', (e) => {
        sVel.x += e.deltaX;
        sVel.y += -e.deltaY;
      }, {
        passive: true
      });
      // ------------- Minimal Self Tests (console only) -------------
      (function selfTests() {
        const tests = [];
        const ok = (name, cond) => tests.push({
          name,
          pass: !!cond
        });
        try {
          ok('DOM要素の存在', ['typingArea', 'visualKb', 'padCanvas', 'ptrDial', 'scrDial'].every(id => document.getElementById(id)));
          // draw() should not throw
          let drew = true;
          try {
            draw();
          } catch (e) {
            drew = false;
            console.error('draw() error:', e);
          }
          ok('draw()が例外を投げない', drew);
          // theme cycle
          const before = document.documentElement.getAttribute('data-theme');
          cycleTheme();
          const after = document.documentElement.getAttribute('data-theme');
          ok('テーマ切替が機能', before !== after);
          // keyboard highlight via synthetic event
          const keyA = document.querySelector('[data-code="KeyA"]');
          let hl = true;
          try {
            typingArea.dispatchEvent(new KeyboardEvent('keydown', {
              bubbles: true,
              code: 'KeyA',
              key: 'a'
            }));
            hl = hl && keyA.classList.contains('down');
            typingArea.dispatchEvent(new KeyboardEvent('keyup', {
              bubbles: true,
              code: 'KeyA',
              key: 'a'
            }));
            hl = hl && !keyA.classList.contains('down');
            hl = hl && keyA.classList.contains('pressed'); // Check if pressed class is added
            $('#resetBtn').click(); // Reset
            hl = hl && !keyA.classList.contains('pressed'); // Check if pressed class is removed
          } catch (e) {
            hl = false;
            console.warn('synthetic key event not allowed', e);
          }
          ok('キー点灯の合成イベント (pressed含む)', hl);
          // dial updates when velocity injected
          const prev = document.getElementById('pspd').textContent;
          const prevS = document.getElementById('sspd').textContent;
          pVel.x += 120;
          pVel.y += 80;
          sVel.x += 200;
          sVel.y += -150;
          setTimeout(() => {
            ok('Motion Compassが更新', document.getElementById('pspd').textContent !== prev);
            ok('Scroll Compassが更新', document.getElementById('sspd').textContent !== prevS);
            console.group('%cSelfTests', 'color:#22c55e');
            tests.forEach(t => console.log((t.pass ? '✔' : '✖'), t.name));
            console.groupEnd();
          }, 80);
        } catch (e) {
          console.warn('selfTests aborted:', e);
        }
      })();
    })();
  </script>
</body>

</html>